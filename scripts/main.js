const translations = {
  ru: {
    'nav.love': 'AKSI LOVE',
    'nav.vision': 'Видение',
    'nav.capabilities': 'Возможности',
    'nav.hypernet': 'Гиперсеть',
    'nav.timeline': 'Путь запуска',
    'nav.console': 'Консоль ИИ',
    'hero.tagline': 'ООО «ЭЛЕКТРИК ПЛЮС» — создатель из будущего',
    'hero.lead': 'AKSI — центральный разум новой эры. Мы создали 3D-пространство, которое реагирует на движение мыши, переворачивается при скролле и раскрывает глубину технологии без подключений к API.',
    'hero.cta': 'Запустить свою систему',
    'hero.secondary': 'Демонстрационный режим работает мгновенно — ваш личный ИИ уже ожил.',
    'love.badge': 'Широкоформатный режим',
    'love.title': 'AKSI LOVE — расширенная сцена синхронизации',
    'love.body': 'Широкий экран запускает эмоциональную сцену, где AKSI и посетитель встречаются в одной волне. Визуальные пластины реагируют на курсор, а нейронное ядро отвечает прямо внутри сайта.',
    'love.stage.title': 'Широкий запуск',
    'love.stage.subtitle': 'Панели собираются вокруг твоего движения',
    'love.panel1.title': 'Реактивная сцена',
    'love.panel1.body': 'Объёмные прямоугольники изгибаются, вращаются и подсвечиваются неоном, когда ты ведёшь курсор по пространству.',
    'love.panel2.title': 'Интеграция ядра',
    'love.panel2.body': 'AKSI LOVE подключается к нейронному ядру и делится общей памятью с консолью, сохраняя контекст каждого сигнала.',
    'love.panel3.title': 'Эмоциональная память',
    'love.panel3.body': 'Локальная память фиксирует эмоции и намерения в реальном времени, формируя хронику взаимодействия.',
    'love.panel4.title': 'Готовность к действию',
    'love.panel4.body': 'Нажми запуск — широкая консоль откроет диалог и подготовит сценарии без серверов и API.',
    'love.launch': 'Запустить AKSI LOVE',
    'love.note': 'Режим раскроется во всю ширину и соединит сцену с внутренним интеллектом.',
    'love.overlay.title': 'Консоль AKSI LOVE',
    'love.overlay.body': 'Широкоформатная консоль собирает визуальные сигналы и ответы ядра, чтобы показать, как AKSI ведёт диалог без внешних API.',
    'love.overlay.point1': 'Все ответы генерируются локально и синхронизируются с памятью основного ядра.',
    'love.overlay.point2': 'Панели HyperNet и консоли делятся контекстом — подсказки обновляются мгновенно.',
    'love.overlay.point3': 'Режим реагирует на движение мыши и скролл, создавая глубину даже на статичном экране.',
    'love.overlay.console': 'Интерактивное ядро',
    'love.overlay.statusLabel': 'Статус',
    'love.overlay.hint': 'Поделись идеей или настроением — AKSI LOVE превратит их в сценарии будущего.',
    'love.overlay.empty': 'Ожидание широкого импульса…',
    'love.overlay.suggestions': 'Попробуйте также',
    'love.overlay.label': 'Сообщение для AKSI LOVE',
    'love.overlay.placeholder': 'Опиши ощущение или задачу…',
    'love.overlay.send': 'Отправить сигнал',
    'love.overlay.close': 'Закрыть режим AKSI LOVE',
    'love.overlay.status.idle': 'Готова к импульсу',
    'love.overlay.status.sync': 'Синхронизация сцены…',
    'love.overlay.status.answer': 'Генерация ответа…',
    'love.overlay.welcome': 'AKSI LOVE активирует сцену и подключает совместную память. Наблюдай, как ответ рождается внутри страницы.',
    'love.overlay.autoprompt': 'Синхронизируй широкую сцену AKSI LOVE с эмоциями пользователя и предложи шаги для совместного запуска.',
    'love.overlay.fallback': 'Режим работает автономно: представь, что сцена откликается на тебя и задаёт тон будущему.',
    'vision.title': 'Новая эра технологий',
    'vision.body': 'ООО «ЭЛЕКТРИК ПЛЮС» объединяет визуальные слои, память и эмоциональную логику, чтобы показать, как будет ощущаться интерфейс будущего. Без серверов и подписок — только чистое взаимодействие.',
    'vision.card1.title': 'Глубокое пространство',
    'vision.card1.body': 'Объёмные пластины реагируют на курсор и раскрываются при прокрутке, создавая эффект персонального метавселенной.',
    'vision.card2.title': 'Сознательный интеллект',
    'vision.card2.body': 'AKSI анализирует контекст, формирует личную память и предлагает решения, будто бы читая ваше намерение.',
    'vision.card3.title': 'Чистая эстетика',
    'vision.card3.body': 'Градиенты, стеклянные панели и неоновые блики формируют узнаваемый язык, созданный ООО «ЭЛЕКТРИК ПЛЮС».',
    'capabilities.title': 'Объёмные возможности AKSI',
    'capabilities.body': 'Каждый модуль чувствует движение, адаптируется к глубине и держит пользователя в потоке. Это симфония интерфейса и искусственного интеллекта.',
    'capability.one.title': 'Голографические сцены',
    'capability.one.body': 'Прямоугольные абстракции вращаются вслед за курсором и переосмысливают понятие панели управления.',
    'capability.two.title': 'Память и логика',
    'capability.two.body': 'Локальная память хранит выбор пользователя, чтобы AKSI отвечала точнее с каждым взаимодействием.',
    'capability.three.title': 'Мгновенный запуск',
    'capability.three.body': 'Демо работает автономно — нажмите кнопку и система активирует сценарий без подключения к API.',
    'hypernet.title': 'AKSI HyperNet Explorer',
    'hypernet.subtitle': 'Сканируй континенты данных, подключай сигналы и запускай действия без внешних API.',
    'hypernet.status.idle': 'Режим ожидания',
    'hypernet.status.scanning': 'Сканирование сети…',
    'hypernet.status.ready': 'Сеть синхронизирована',
    'hypernet.status.executing': 'Выполнение сценария…',
    'hypernet.search.label': 'Поиск по гиперсети',
    'hypernet.search.placeholder': 'Введите запрос или вставьте ссылку, чтобы просканировать интернет…',
    'hypernet.search.submit': 'Сканировать',
    'hypernet.filters.title': 'Фильтры сигналов',
    'hypernet.filters.trends': 'Тренды',
    'hypernet.filters.infrastructure': 'Инфраструктура',
    'hypernet.filters.markets': 'Рынки',
    'hypernet.filters.culture': 'Культура',
    'hypernet.filters.research': 'Исследования',
    'hypernet.results.empty': 'Сеть ожидает ваш запрос — введите тему, чтобы собрать данные.',
    'hypernet.summary.total': 'Найдено сигналов: {count}',
    'hypernet.summary.selected': 'В приоритете: {count}',
    'hypernet.summary.filters.none': 'Фильтры отключены — анализируются все источники.',
    'hypernet.summary.filters.active': 'Активны фильтры: {filters}',
    'hypernet.metric.freshness': 'Свежесть',
    'hypernet.metric.credibility': 'Достоверность',
    'hypernet.metric.amplitude': 'Охват',
    'hypernet.actions.title': 'Сценарии действий',
    'hypernet.actions.subtitle': 'Выбери сценарий, чтобы HyperNet подготовила отчёт или последовательность действий.',
    'hypernet.actions.run': 'Запустить сценарий',
    'hypernet.actions.digest': 'Квантовый дайджест',
    'hypernet.actions.digest.description': 'Собирает ключевые сигналы и превращает их в сжатый отчёт.',
    'hypernet.actions.pulse': 'Импульс возможностей',
    'hypernet.actions.pulse.description': 'Расставляет приоритеты и формирует окно возможностей на основе выбранных источников.',
    'hypernet.actions.deploy': 'Пакет действий',
    'hypernet.actions.deploy.description': 'Строит пошаговый план действий и назначает виртуальных агентов.',
    'hypernet.log.title': 'Журнал HyperNet',
    'hypernet.log.empty': 'Журнал пуст — начните поиск, чтобы появилось событие.',
    'timeline.title': 'Как запускается AKSI',
    'timeline.body': 'Мы демонстрируем три шага новой реальности: от пробуждения визуальных фрагментов до парящей надписи и вызова системы.',
    'timeline.step1': 'Фрагменты активируются, собираясь в надпись AKSI и формируя базовый слой памяти.',
    'timeline.step2': 'Глубина сцены откликается на движение мыши, заставляя панели вращаться и раскрывать данные.',
    'timeline.step3': 'Кнопка «Запустить свою систему» открывает автономный сценарий, где АКSI ведёт пользователя дальше.',
    'ai.title': 'Консоль AKSI Neural Core',
    'ai.subtitle': 'Попробуйте встроенный интеллект: автономные ответы, память и моделирование решений без подключения к внешним API.',
    'ai.hint': 'Спроси о возможностях, попроси план действий или придумай сценарий будущего.',
    'ai.memory.title': 'Память диалогов',
    'ai.memory.empty': 'История пока пуста — задай первый вопрос.',
    'ai.memory.timestamp': 'Время',
    'ai.memory.intent': 'Интент',
    'ai.suggestions.title': 'Идеи для вопросов',
    'ai.input.placeholder': 'Введите запрос или задачу для AKSI…',
    'ai.send': 'Отправить',
    'ai.system.awake': 'AKSI подключилась к внутреннему ядру. Я готова вести автономные диалоги.',
    'ai.system.memoryRestored': 'Восстановлено фрагментов памяти: ',
    'ai.system.newDialog': 'Новый диалог активирован. Используйте подсказки или задайте собственный вопрос.',
    'ai.memory.capacityTitle': 'Масштаб обработки',
    'ai.memory.capacityFragments': 'Фрагменты',
    'ai.memory.capacityIntents': 'Уникальные намерения',
    'ai.memory.capacityTokens': 'Обработано слов',
    'ai.memory.capacityStream': 'Потоковые сигналы',
    'ai.insights.title': 'Аналитика ядра',
    'ai.insights.empty': 'Недостаточно данных — начните взаимодействие, чтобы активировать аналитику.',
    'ai.insights.updated': 'Обновлено',
    'ai.stream.title': 'Реальный поток данных',
    'ai.stream.empty': 'Датчики пока молчат — двигайте курсор или прокручивайте, чтобы увидеть телеметрию.',
    'ai.stream.channel.dialogue': 'Диалог',
    'ai.stream.channel.motion': 'Движение',
    'ai.stream.channel.scroll': 'Скролл',
    'ai.stream.channel.heartbeat': 'Пульс ядра',
    'ai.stream.channel.external': 'Источник',
    'final.title': 'Готовы увидеть создателя в действии?',
    'final.body': 'Перенеситесь в будущее: активируйте автономный режим AKSI и ощутите, как решение от ООО «ЭЛЕКТРИК ПЛЮС» реагирует на каждое движение.',
    'final.cta': 'Запустить свою систему',
    'footer': 'AKSI — ООО «ЭЛЕКТРИК ПЛЮС» создатель © 2046 — будущее развёрнуто сегодня.'
  },
  en: {
    'nav.love': 'AKSI LOVE',
    'nav.vision': 'Vision',
    'nav.capabilities': 'Capabilities',
    'nav.hypernet': 'HyperNet',
    'nav.timeline': 'Launch Path',
    'nav.console': 'AI Console',
    'hero.tagline': 'OOO Elektrik Plus — creator from the future',
    'hero.lead': 'AKSI is the central mind of a new era. A 3D universe reacts to your cursor, flips with scroll and reveals technology depth without any API connections.',
    'hero.cta': 'Launch your system',
    'hero.secondary': 'The demo runs instantly — your personal AI is already alive.',
    'love.badge': 'Wide-format mode',
    'love.title': 'AKSI LOVE — expansive sync stage',
    'love.body': 'A panoramic launch pad where AKSI and the visitor meet on the same wavelength. Reactive plates follow your cursor while the neural core replies directly inside the site.',
    'love.stage.title': 'Wide launch',
    'love.stage.subtitle': 'Panels orbit around your motion',
    'love.panel1.title': 'Reactive stage',
    'love.panel1.body': 'Volumetric rectangles bend, spin and ignite gradients as you glide across the space.',
    'love.panel2.title': 'Core integration',
    'love.panel2.body': 'AKSI LOVE links to the neural core and shares memory with the console, preserving every signal.',
    'love.panel3.title': 'Emotional memory',
    'love.panel3.body': 'Local memory captures emotions and intents in real time, building a living chronicle.',
    'love.panel4.title': 'Ready for action',
    'love.panel4.body': 'Press launch — the panoramic console opens a dialogue and prepares action arcs without servers.',
    'love.launch': 'Launch AKSI LOVE',
    'love.note': 'The mode expands to full width and binds the stage to the internal intelligence.',
    'love.overlay.title': 'AKSI LOVE Console',
    'love.overlay.body': 'The widescreen console fuses visual signals and core replies to show how AKSI converses without external APIs.',
    'love.overlay.point1': 'All answers are generated locally and synchronised with the primary memory.',
    'love.overlay.point2': 'HyperNet and console share context, so prompts refresh instantly.',
    'love.overlay.point3': 'The mode reacts to pointer movement and scroll, creating depth even on a static display.',
    'love.overlay.console': 'Interactive core',
    'love.overlay.statusLabel': 'Status',
    'love.overlay.hint': 'Share an idea or a feeling — AKSI LOVE will transform it into suggestions and action steps.',
    'love.overlay.empty': 'Awaiting the wide impulse…',
    'love.overlay.suggestions': 'Try also',
    'love.overlay.label': 'Message for AKSI LOVE',
    'love.overlay.placeholder': 'Describe a feeling or task…',
    'love.overlay.send': 'Send signal',
    'love.overlay.close': 'Close AKSI LOVE mode',
    'love.overlay.status.idle': 'Ready for impulse',
    'love.overlay.status.sync': 'Synchronising the stage…',
    'love.overlay.status.answer': 'Generating response…',
    'love.overlay.welcome': 'AKSI LOVE activates the stage and plugs into shared memory. Watch the answer emerge inside the page.',
    'love.overlay.autoprompt': 'Synchronise the AKSI LOVE widescreen stage with the visitor’s emotion and suggest steps for a joint launch.',
    'love.overlay.fallback': 'The mode runs autonomously: imagine the scene reacting to you and setting the tone for the future.',
    'vision.title': 'A new technological age',
    'vision.body': 'OOO Elektrik Plus fuses visual layers, memory and emotional logic to show how interfaces of tomorrow will feel. No servers or subscriptions — just pure interaction.',
    'vision.card1.title': 'Deep space',
    'vision.card1.body': 'Volumetric plates follow your cursor and unfold when you scroll, creating the sense of a personal metaverse.',
    'vision.card2.title': 'Conscious intelligence',
    'vision.card2.body': 'AKSI analyses context, forms personal memory and offers guidance as if it could read your intent.',
    'vision.card3.title': 'Pure aesthetics',
    'vision.card3.body': 'Gradients, glass panels and neon glow define the signature language crafted by OOO Elektrik Plus.',
    'capabilities.title': 'Volumetric powers of AKSI',
    'capabilities.body': 'Every module senses motion, adapts to depth and keeps the user in flow — a symphony of interface and artificial intelligence.',
    'capability.one.title': 'Holographic scenes',
    'capability.one.body': 'Rectangular abstractions spin with your cursor and reinvent the control surface.',
    'capability.two.title': 'Memory and logic',
    'capability.two.body': 'Local memory keeps user choices so AKSI can respond more accurately with every interaction.',
    'capability.three.title': 'Instant ignition',
    'capability.three.body': 'The demo runs autonomously — press the button and the system orchestrates the journey without any API.',
    'hypernet.title': 'AKSI HyperNet Explorer',
    'hypernet.subtitle': 'Scan data continents, plug into signals and trigger actions without external APIs.',
    'hypernet.status.idle': 'Idle mode',
    'hypernet.status.scanning': 'Scanning the mesh…',
    'hypernet.status.ready': 'Mesh synchronised',
    'hypernet.status.executing': 'Executing scenario…',
    'hypernet.search.label': 'HyperNet search',
    'hypernet.search.placeholder': 'Type a query or paste a link to sweep the internet…',
    'hypernet.search.submit': 'Scan',
    'hypernet.filters.title': 'Signal filters',
    'hypernet.filters.trends': 'Trends',
    'hypernet.filters.infrastructure': 'Infrastructure',
    'hypernet.filters.markets': 'Markets',
    'hypernet.filters.culture': 'Culture',
    'hypernet.filters.research': 'Research',
    'hypernet.results.empty': 'The mesh awaits your command — enter a topic to gather data.',
    'hypernet.summary.total': 'Signals found: {count}',
    'hypernet.summary.selected': 'Priority queue: {count}',
    'hypernet.summary.filters.none': 'No filters applied — scanning the entire field.',
    'hypernet.summary.filters.active': 'Filters active: {filters}',
    'hypernet.metric.freshness': 'Freshness',
    'hypernet.metric.credibility': 'Credibility',
    'hypernet.metric.amplitude': 'Reach',
    'hypernet.actions.title': 'Action scenarios',
    'hypernet.actions.subtitle': 'Choose a scenario for HyperNet to craft a report or command chain.',
    'hypernet.actions.run': 'Run scenario',
    'hypernet.actions.digest': 'Quantum digest',
    'hypernet.actions.digest.description': 'Collects leading signals and turns them into a condensed report.',
    'hypernet.actions.pulse': 'Opportunity pulse',
    'hypernet.actions.pulse.description': 'Prioritises signals and maps the opportunity window.',
    'hypernet.actions.deploy': 'Action package',
    'hypernet.actions.deploy.description': 'Builds a step-by-step action plan and assigns virtual agents.',
    'hypernet.log.title': 'HyperNet log',
    'hypernet.log.empty': 'Log is clear — start a scan to record events.',
    'timeline.title': 'How AKSI awakens',
    'timeline.body': 'Experience three steps of the new reality: fragments awakening, levitating typography and the system call-to-action.',
    'timeline.step1': 'Fragments ignite, assembling into the AKSI mark while forming the primary memory layer.',
    'timeline.step2': 'Scene depth responds to every pointer move, spinning panels to expose multidimensional data.',
    'timeline.step3': '“Launch your system” triggers an autonomous scenario where AKSI guides the explorer forward.',
    'ai.title': 'AKSI Neural Core Console',
    'ai.subtitle': 'Engage the embedded intelligence: autonomous answers, memory and solution modeling without any external API.',
    'ai.hint': 'Ask about capabilities, request an action plan or imagine future scenarios.',
    'ai.memory.title': 'Dialogue Memory',
    'ai.memory.empty': 'Memory is clear — ask the first question.',
    'ai.memory.timestamp': 'Timestamp',
    'ai.memory.intent': 'Intent',
    'ai.suggestions.title': 'Question ideas',
    'ai.input.placeholder': 'Type a request or task for AKSI…',
    'ai.send': 'Send',
    'ai.system.awake': 'AKSI connected to the internal core. Autonomous dialogue is ready.',
    'ai.system.memoryRestored': 'Memory fragments restored: ',
    'ai.system.newDialog': 'New dialogue activated. Use the prompts or craft your own question.',
    'ai.memory.capacityTitle': 'Processing scale',
    'ai.memory.capacityFragments': 'Fragments',
    'ai.memory.capacityIntents': 'Unique intents',
    'ai.memory.capacityTokens': 'Words processed',
    'ai.memory.capacityStream': 'Live signals',
    'ai.insights.title': 'Core analytics',
    'ai.insights.empty': 'Not enough data yet — start interacting to unlock analytics.',
    'ai.insights.updated': 'Updated',
    'ai.stream.title': 'Realtime data stream',
    'ai.stream.empty': 'Sensors are quiet for now — move the cursor or scroll to trigger telemetry.',
    'ai.stream.channel.dialogue': 'Dialogue',
    'ai.stream.channel.motion': 'Motion',
    'ai.stream.channel.scroll': 'Scroll',
    'ai.stream.channel.heartbeat': 'Core heartbeat',
    'ai.stream.channel.external': 'Source',
    'final.title': 'Ready to witness the creator in motion?',
    'final.body': 'Step into the future: activate AKSI’s autonomous mode and feel how OOO Elektrik Plus answers every gesture.',
    'final.cta': 'Launch your system',
    'footer': 'AKSI — OOO Elektrik Plus creator © 2046 — the future unfolds today.'
  }
};

const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

let sensorsBootstrapped = false;

function getDictionary(lang) {
  return translations[lang] || translations.ru;
}

function formatDateTimeDisplay(date, lang = 'ru') {
  const locale = lang === 'en' ? 'en-US' : 'ru-RU';
  return new Intl.DateTimeFormat(locale, {
    dateStyle: 'full',
    timeStyle: 'medium'
  }).format(date);
}

function setLanguage(lang) {
  const dictionary = getDictionary(lang);
  document.documentElement.lang = lang === 'en' ? 'en' : 'ru';
  document.querySelectorAll('[data-i18n]').forEach((node) => {
    const key = node.dataset.i18n;
    if (key && dictionary[key]) {
      node.textContent = dictionary[key];
    }
  });
  document.querySelectorAll('[data-i18n-placeholder]').forEach((node) => {
    const key = node.dataset.i18nPlaceholder;
    if (key && dictionary[key]) {
      node.setAttribute('placeholder', dictionary[key]);
    }
  });
  document.querySelectorAll('[data-i18n-aria]').forEach((node) => {
    const key = node.dataset.i18nAria;
    if (key && dictionary[key]) {
      node.setAttribute('aria-label', dictionary[key]);
    }
  });
  document.querySelectorAll('[data-lang-switch]').forEach((button) => {
    button.classList.toggle('active', button.dataset.langSwitch === lang);
  });
  localStorage.setItem('aksi-language', lang);
  document.dispatchEvent(new CustomEvent('aksi:language-changed', { detail: { lang } }));
}

function initLanguage() {
  const saved = localStorage.getItem('aksi-language');
  const initial = saved === 'en' ? 'en' : 'ru';
  setLanguage(initial);
  document.querySelectorAll('[data-lang-switch]').forEach((button) => {
    button.addEventListener('click', () => {
      const lang = button.dataset.langSwitch;
      setLanguage(lang);
    });
  });
}

function initFragments() {
  const fragments = document.querySelectorAll('.fragment');
  fragments.forEach((fragment, index) => {
    const offsetX = (Math.random() * 420 - 210).toFixed(1);
    const offsetY = (Math.random() * 320 - 160).toFixed(1);
    const offsetZ = (Math.random() * 480 - 240).toFixed(1);
    const rotX = (Math.random() * 90 - 45).toFixed(1);
    const rotY = (Math.random() * 120 - 60).toFixed(1);
    fragment.style.setProperty('--startX', `${offsetX}px`);
    fragment.style.setProperty('--startY', `${offsetY}px`);
    fragment.style.setProperty('--startZ', `${offsetZ}px`);
    fragment.style.setProperty('--startRotX', `${rotX}deg`);
    fragment.style.setProperty('--startRotY', `${rotY}deg`);
    fragment.style.animationDelay = `${0.12 * index}s`;
  });
}

function initTilt() {
  if (prefersReducedMotion) return;
  const tiltElements = Array.from(document.querySelectorAll('[data-tilt]'));
  const abstractShapes = Array.from(document.querySelectorAll('.abstract-shape'));
  let pointerX = window.innerWidth / 2;
  let pointerY = window.innerHeight / 2;
  let ticking = false;

  window.addEventListener('pointermove', (event) => {
    pointerX = event.clientX;
    pointerY = event.clientY;
    if (!ticking) {
      window.requestAnimationFrame(() => {
        applyTilt(pointerX, pointerY, tiltElements, abstractShapes);
        ticking = false;
      });
      ticking = true;
    }
  });

  applyTilt(pointerX, pointerY, tiltElements, abstractShapes);
}

function applyTilt(pointerX, pointerY, tiltElements, abstractShapes) {
  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;
  const normX = (pointerX - centerX) / centerX;
  const normY = (pointerY - centerY) / centerY;

  tiltElements.forEach((element) => {
    const depth = parseFloat(element.dataset.tilt || '1');
    const tiltX = (normY * -8 * depth).toFixed(2);
    const tiltY = (normX * 10 * depth).toFixed(2);
    element.style.setProperty('--tiltX', `${tiltX}deg`);
    element.style.setProperty('--tiltY', `${tiltY}deg`);
  });

  abstractShapes.forEach((shape) => {
    const depth = parseFloat(shape.dataset.depth || '1');
    const shapeTiltX = (normY * -14 * depth).toFixed(2);
    const shapeTiltY = (normX * 18 * depth).toFixed(2);
    shape.style.setProperty('--depth', depth);
    shape.style.setProperty('--tiltX', `${shapeTiltX}deg`);
    shape.style.setProperty('--tiltY', `${shapeTiltY}deg`);
  });
}

function initScrollDepth() {
  if (prefersReducedMotion) return;
  const abstractShapes = Array.from(document.querySelectorAll('.abstract-shape'));
  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target.classList.add('is-visible');
      }
    });
  }, { threshold: 0.2 });

  document.querySelectorAll('.vision-card, .capability, .timeline-step').forEach((card) => {
    observer.observe(card);
  });

  const updateScroll = () => {
    const scroll = window.scrollY;
    abstractShapes.forEach((shape, index) => {
      const depth = parseFloat(shape.dataset.depth || '1');
      const rotate = ((scroll * 0.08) + index * 14) * depth;
      const translate = Math.sin((scroll / 180) + index) * 60 * depth;
      shape.style.setProperty('--scrollRotate', `${rotate}deg`);
      shape.style.setProperty('--scrollTranslate', `${translate}px`);
    });
  };

  updateScroll();
  window.addEventListener('scroll', () => {
    window.requestAnimationFrame(updateScroll);
  });
}

function initCta() {
  const ctas = document.querySelectorAll('.cta-button');
  ctas.forEach((button) => {
    button.addEventListener('click', () => {
      button.classList.add('cta-activated');
      setTimeout(() => button.classList.remove('cta-activated'), 900);
      const target =
        document.querySelector('#love') ||
        document.querySelector('#hypernet') ||
        document.querySelector('#console') ||
        document.querySelector('#timeline');
      if (target) {
        target.scrollIntoView({ behavior: prefersReducedMotion ? 'auto' : 'smooth', block: 'start' });
      }
      const hyperInput = document.querySelector('[data-hypernet-query]');
      const aiInput = document.querySelector('#ai-input');
      const focusTarget = hyperInput || aiInput;
      if (focusTarget) {
        setTimeout(() => focusTarget.focus(), prefersReducedMotion ? 0 : 320);
      }
    });
  });
}

function createAksiNeuralCore() {
  const memoryKey = 'aksi-neural-memory';
  const streamKey = 'aksi-neural-stream';
  const summaryKey = 'aksi-neural-summary';
  const memoryLimit = 48;
  const streamLimit = 60;
  const eventTarget = new EventTarget();
  const knowledgeBase = [
    {
      key: 'vision',
      keywords: ['виден', 'vision', 'мисси', 'philosophy', 'философ', 'будущ', 'future'],
      summary: {
        ru: 'AKSI показывает тактильное будущее, где интерфейс реагирует на каждое намерение.',
        en: 'AKSI frames a tactile future where the interface reacts to every intention.'
      },
      detail: {
        ru: 'Мы связываем визуальные слои, эмоциональную аналитику и гибкие сценарии, чтобы демонстрировать новую эру человеко-центричных систем.',
        en: 'We fuse visual layers, emotional analytics and adaptive scenarios to showcase a new era of human-centred systems.'
      }
    },
    {
      key: 'capabilities',
      keywords: ['возмож', 'capabil', 'skill', 'умеешь', 'abilities', 'модуль'],
      summary: {
        ru: 'AKSI автономно моделирует решения, хранит память и создаёт визуальные сцены.',
        en: 'AKSI autonomously models solutions, stores memory and orchestrates visual scenes.'
      },
      detail: {
        ru: 'Ядро сочетает подсказки, генеративные сценарии и внутренние датчики, поэтому ответы включают анализ, эмпатию и конкретные шаги.',
        en: 'The core blends prompts, generative scenarios and internal sensors so answers include analysis, empathy and concrete steps.'
      }
    },
    {
      key: 'timeline',
      keywords: ['путь', 'этап', 'шаг', 'launch', 'roadmap', 'timeline', 'step'],
      summary: {
        ru: 'Запуск состоит из пробуждения фрагментов, синхронизации глубины и активации режима.',
        en: 'Launch spans fragment awakening, depth synchronisation and activation of the mode.'
      },
      detail: {
        ru: 'Каждый этап можно кастомизировать: от предзапуска с визуальными репетициями до сопровождения пользователя внутри 3D-полотна.',
        en: 'Every stage is customisable: from pre-launch visual rehearsals to guiding the user inside the 3D canvas.'
      }
    },
    {
      key: 'company',
      keywords: ['электрик', 'plus', 'creator', 'company', 'brand', 'ооо', 'electric'],
      summary: {
        ru: 'ООО «ЭЛЕКТРИК ПЛЮС» разрабатывает AKSI как доступный автономный интеллект.',
        en: 'OOO Elektrik Plus develops AKSI as an accessible autonomous intelligence.'
      },
      detail: {
        ru: 'Мы показываем, что ИИ может жить прямо в браузере, уважать приватность и при этом впечатлять глубиной взаимодействия.',
        en: 'We prove that AI can live directly in the browser, respect privacy and still impress with interaction depth.'
      }
    },
    {
      key: 'memory',
      keywords: ['память', 'memory', 'запомни', 'remember', 'history', 'истори'],
      summary: {
        ru: 'Память фиксирует намерения и выводы, чтобы ответы были персональными.',
        en: 'Memory captures intents and conclusions so answers stay personal.'
      },
      detail: {
        ru: 'Фрагменты сохраняются локально, их можно инспектировать в панели справа — никакие данные не покидают устройство.',
        en: 'Fragments persist locally and surface in the side panel—no data leaves the device.'
      }
    }
  ];

  const baseSuggestions = {
    ru: [
      'Сформируй стратегию запуска AKSI для города будущего',
      'Подскажи, как использовать память системы для обучения команде',
      'Сгенерируй историю взаимодействия пользователя с интерфейсом'
    ],
    en: [
      'Design a launch strategy for AKSI in a future city',
      'Explain how to use the system memory to train a team',
      'Generate a user interaction story with the interface'
    ]
  };

  const intentSuggestions = {
    ru: {
      greeting: ['Покажи главные возможности AKSI', 'Какие шаги нужны для внедрения?', 'Чем память помогает пользователю?'],
      time: ['Напомни ключевые события сегодня', 'Как синхронизировать расписание с AKSI?', 'Что запланировать на следующий шаг?'],
      plan: ['Распиши этапы запуска продукта', 'Как распределить роли команды?', 'Какие метрики отслеживать?'],
      capability: ['Расскажи про визуальные сцены', 'Как работает автономный режим?', 'Какие есть способы расширения?'],
      creative: ['Придумай сюжет о взаимодействии с AKSI', 'Опиши будущее рабочее место', 'Как AKSI поддержит город будущего?'],
      support: ['Подскажи чек-лист диагностики', 'Как оптимизировать производительность?', 'Как сохранить настройки среды?'],
      company: ['Какая миссия у ООО «ЭЛЕКТРИК ПЛЮС»?', 'Как объяснить ценность AKSI клиенту?', 'Какие проекты уже реализованы?']
    },
    en: {
      greeting: ['Show AKSI’s main capabilities', 'Which steps are required to deploy it?', 'How does the memory help the user?'],
      time: ['Remind today’s key events', 'How to sync a schedule with AKSI?', 'What should be planned next?'],
      plan: ['Outline the product launch stages', 'How should the team roles be distributed?', 'Which metrics should we track?'],
      capability: ['Describe the visual scenes', 'How does the autonomous mode behave?', 'Which extension options exist?'],
      creative: ['Create a story about engaging with AKSI', 'Describe the workplace of the future', 'How will AKSI support a smart city?'],
      support: ['Share a diagnostics checklist', 'How to optimise performance?', 'How to preserve environment settings?'],
      company: ['What is Elektrik Plus mission?', 'How to explain AKSI’s value to a client?', 'Which projects already launched?']
    }
  };

  const state = {
    memory: loadMemory(),
    stream: loadStream(),
    summary: loadSummary(),
    stats: null
  };

  if (!state.summary) {
    state.stats = computeStats();
    rebuildSummary();
  } else {
    state.stats = state.summary.stats || computeStats();
  }

  function normaliseLang(lang) {
    return lang === 'en' ? 'en' : 'ru';
  }

  function loadMemory() {
    try {
      const raw = JSON.parse(localStorage.getItem(memoryKey));
      if (Array.isArray(raw)) {
        return raw.slice(-memoryLimit).map((entry) => ({
          ...entry,
          timestamp: entry.timestamp || entry.ts || new Date().toISOString()
        }));
      }
    } catch (error) {
      console.warn('AKSI memory restore failed', error);
    }
    return [];
  }

  function loadStream() {
    try {
      const raw = JSON.parse(localStorage.getItem(streamKey));
      if (Array.isArray(raw)) {
        return raw.slice(-streamLimit).map((entry) => ({
          ...entry,
          timestamp: entry.timestamp || new Date().toISOString(),
          summary: typeof entry.summary === 'object' ? entry.summary : { ru: entry.summary, en: entry.summary }
        }));
      }
    } catch (error) {
      console.warn('AKSI stream restore failed', error);
    }
    return [];
  }

  function loadSummary() {
    try {
      const raw = JSON.parse(localStorage.getItem(summaryKey));
      if (raw && typeof raw === 'object') {
        return raw;
      }
    } catch (error) {
      console.warn('AKSI summary restore failed', error);
    }
    return null;
  }

  function persistMemory() {
    try {
      const trimmed = state.memory.slice(-memoryLimit);
      localStorage.setItem(memoryKey, JSON.stringify(trimmed));
    } catch (error) {
      console.warn('AKSI memory persist failed', error);
    }
  }

  function persistStream() {
    try {
      const trimmed = state.stream.slice(-streamLimit);
      localStorage.setItem(streamKey, JSON.stringify(trimmed));
    } catch (error) {
      console.warn('AKSI stream persist failed', error);
    }
  }

  function persistSummary() {
    try {
      if (state.summary) {
        localStorage.setItem(summaryKey, JSON.stringify(state.summary));
      } else {
        localStorage.removeItem(summaryKey);
      }
    } catch (error) {
      console.warn('AKSI summary persist failed', error);
    }
  }

  function computeStats() {
    const intents = {};
    let tokens = 0;
    state.memory.forEach((entry) => {
      intents[entry.intent] = (intents[entry.intent] || 0) + 1;
      const userTokens = typeof entry.user === 'string' ? entry.user.split(/\s+/).length : 0;
      const assistantTokens = typeof entry.assistant === 'string' ? entry.assistant.split(/\s+/).length : 0;
      tokens += userTokens + assistantTokens;
    });
    return {
      fragments: state.memory.length,
      intents: Object.keys(intents).length,
      stream: state.stream.length,
      tokens
    };
  }

  function emitSnapshot() {
    const detail = {
      memory: getMemory(),
      stream: getRealtimeFeed(),
      summary: getSummary()
    };
    eventTarget.dispatchEvent(new CustomEvent('update', { detail }));
  }

  function normaliseKeywords(text) {
    if (typeof text !== 'string') return [];
    return text
      .toLowerCase()
      .replace(/[^\p{L}\p{N}\s]+/gu, ' ')
      .split(/\s+/)
      .filter((word) => word.length > 3);
  }

  function rebuildSummary() {
    const tally = new Map();
    const accumulate = (text) => {
      normaliseKeywords(text).forEach((word) => {
        const count = tally.get(word) || 0;
        tally.set(word, count + 1);
      });
    };
    state.memory.forEach((entry) => {
      accumulate(entry.user);
      accumulate(entry.assistant);
    });
    state.stream.forEach((entry) => {
      if (entry.summary && typeof entry.summary === 'object') {
        accumulate(entry.summary.ru);
        accumulate(entry.summary.en);
      } else {
        accumulate(entry.summary);
      }
      if (Array.isArray(entry.payload?.keywords)) {
        entry.payload.keywords.forEach((word) => {
          const lower = String(word || '').toLowerCase();
          if (lower.length > 1) {
            tally.set(lower, (tally.get(lower) || 0) + 2);
          }
        });
      }
    });
    const sorted = Array.from(tally.entries())
      .filter(([, count]) => count > 1)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 8)
      .map(([word, count]) => ({ word, count }));
    state.stats = computeStats();
    state.summary = {
      topKeywords: sorted,
      stats: state.stats,
      lastUpdated: new Date().toISOString()
    };
    persistSummary();
  }

  function getRealtimeFeed() {
    return state.stream.slice(-streamLimit);
  }

  function getSummary() {
    if (!state.summary) {
      rebuildSummary();
    }
    return state.summary;
  }

  function findKnowledge(lower) {
    let best = null;
    let bestScore = 0;
    knowledgeBase.forEach((entry) => {
      const score = entry.keywords.reduce((acc, keyword) => (lower.includes(keyword) ? acc + 1 : acc), 0);
      if (score > bestScore) {
        best = entry;
        bestScore = score;
      }
    });
    return bestScore > 0 ? best : null;
  }

  function detectIntent(lower) {
    if (/(?:привет|здрав|салют|hi\b|hello|hey|добрый|morning|evening)/.test(lower)) {
      return 'greeting';
    }
    if (/(?:время|дата|сегодня|сейчас|time|date|today|clock|schedule)/.test(lower)) {
      return 'time';
    }
    if (/(?:план|roadmap|strategy|стратег|шаг|как начать|как запустить|этап)/.test(lower)) {
      return 'plan';
    }
    if (/(?:возможн|capabil|умеешь|что ты можешь|abilities|skills|функци)/.test(lower)) {
      return 'capability';
    }
    if (/(?:story|истори|придумай|imagine|scenario|сюжет|creative|vision)/.test(lower)) {
      return 'creative';
    }
    if (/(?:problem|issue|debug|support|сломал|не работ|help|diagnostic|почини)/.test(lower)) {
      return 'support';
    }
    if (/(?:электрик|plus|company|brand|creator|ооо|кто вы)/.test(lower)) {
      return 'company';
    }
    if (/(?:памят|memory|remember|history)/.test(lower)) {
      return 'memory';
    }
    return 'general';
  }

  function describeMemory(lang) {
    if (!state.memory.length) return null;
    const last = state.memory[state.memory.length - 1];
    if (!last) return null;
    if (lang === 'en') {
      return `I noted that you previously asked about “${last.user}”. I can build on that context.`;
    }
    return `Я зафиксировала, что ранее ты спрашивал: «${last.user}». Могу продолжить, опираясь на это.`;
  }

  function summariseRealtime(lang) {
    const summary = getSummary();
    if (!summary) return null;
    const stats = summary.stats || computeStats();
    const top = (summary.topKeywords || []).slice(0, 3);
    const keywordLine = top.length
      ? top
          .map((item) => `${item.word} ×${item.count}`)
          .join(lang === 'en' ? ', ' : ', ')
      : null;
    if (lang === 'en') {
      const base = `Realtime engine now holds ${stats.fragments} fragments, ${stats.stream} live signals and processed ${stats.tokens} words.`;
      return keywordLine ? `${base} Focus topics: ${keywordLine}.` : base;
    }
    const base = `Реактор в реальном времени хранит ${stats.fragments} фрагментов, ${stats.stream} потоковых сигналов и обработал ${stats.tokens} слов.`;
    return keywordLine ? `${base} В фокусе темы: ${keywordLine}.` : base;
  }

  function buildResponse(text, lang) {
    const lower = text.toLowerCase();
    const intent = detectIntent(lower);
    const knowledge = findKnowledge(lower);
    const dictionary = getDictionary(lang);
    const paragraphs = [];
    const now = new Date();

    switch (intent) {
      case 'greeting':
        if (lang === 'en') {
          paragraphs.push('Hello! I am AKSI, running fully local in your browser. Let’s design the future together.');
        } else {
          paragraphs.push('Привет! Я AKSI и полностью работаю локально в твоём браузере. Давай спроектируем будущее вместе.');
        }
        break;
      case 'time':
        paragraphs.push(lang === 'en'
          ? `Right now it is ${formatDateTimeDisplay(now, lang)}. I synchronised the console time with your device.`
          : `Сейчас ${formatDateTimeDisplay(now, lang)}. Я синхронизировала консоль с твоим устройством.`);
        paragraphs.push(lang === 'en'
          ? 'Need reminders or a tempo map for today? Tell me the context and I will shape it.'
          : 'Нужны напоминания или темп на сегодня? Расскажи контекст, и я его спроектирую.');
        break;
      case 'plan': {
        const steps = lang === 'en'
          ? [
              '• Sense the current objective and stakeholders.',
              '• Prototype a volumetric scene showing the journey.',
              '• Activate AKSI memory to capture milestones and feedback.'
            ]
          : [
              '• Считать цель и вовлечённых участников.',
              '• Спроектировать объёмную сцену, визуализирующую путь.',
              '• Активировать память AKSI, чтобы фиксировать вехи и обратную связь.'
            ];
        paragraphs.push(lang === 'en'
          ? 'Here is a fast deployment arc. Adjust each bullet and I will elaborate.'
          : 'Вот ускоренный маршрут развёртывания. Уточни любой пункт — я раскрою подробнее.');
        paragraphs.push(steps.join('\n'));
        break;
      }
      case 'capability':
        paragraphs.push(lang === 'en'
          ? 'My core blends scenario simulation, narrative generation and diagnostics. I analyse intents, create action plans and produce visuals — all without external APIs.'
          : 'Моё ядро сочетает моделирование сценариев, генерацию нарративов и диагностику. Я анализирую намерения, строю планы действий и создаю визуальные подсказки без внешних API.');
        break;
      case 'creative':
        paragraphs.push(lang === 'en'
          ? 'Imagine entering a chamber where glass panels orbit around you. AKSI narrates the next decision, learns your tone and lights the path with volumetric hints.'
          : 'Представь зал, где стеклянные панели орбитой вращаются вокруг. AKSI озвучивает следующее решение, считывает настроение и подсвечивает путь объёмными подсказками.');
        paragraphs.push(lang === 'en'
          ? 'Give me characters, constraints or emotions — I will weave them into a scene.'
          : 'Дай персонажей, ограничения или эмоции — я вплету их в сцену.');
        break;
      case 'support':
        paragraphs.push(lang === 'en'
          ? 'Let me run a local diagnostic: check pointer responsiveness, confirm animations and review stored fragments.'
          : 'Запускаю локальную диагностику: проверяю отклик курсора, подтверждаю анимации и анализирую сохранённые фрагменты.');
        paragraphs.push(lang === 'en'
          ? 'Describe the symptom and I will produce a checklist or code snippet that fits.'
          : 'Опиши симптом — подготовлю чек-лист или фрагмент кода, который поможет.');
        break;
      case 'company':
        paragraphs.push(lang === 'en'
          ? 'OOO Elektrik Plus built AKSI to demonstrate that premium AI experiences can exist entirely on the client side.'
          : 'ООО «ЭЛЕКТРИК ПЛЮС» создала AKSI, чтобы показать: премиальный ИИ может жить прямо на стороне клиента.');
        paragraphs.push(lang === 'en'
          ? 'We merge design, engineering and empathy — that combination powers the console you are using now.'
          : 'Мы объединяем дизайн, инженерию и эмпатию — именно этот сплав питает консоль, которой ты пользуешься.');
        break;
      case 'memory':
        if (state.memory.length) {
          const fragments = state.memory.slice(-3).map((entry) => `• ${formatDateTimeDisplay(new Date(entry.timestamp), lang)} — ${entry.intent}`);
          paragraphs.push(lang === 'en'
            ? 'Here are the latest fragments I preserved:'
            : 'Вот последние фрагменты, которые я сохранила:');
          paragraphs.push(fragments.join('\n'));
        } else {
          paragraphs.push(lang === 'en'
            ? 'Memory is clear right now. Every new prompt will create a fresh fragment.'
            : 'Память пока чистая. Каждый новый запрос сформирует свежий фрагмент.');
        }
        break;
      default:
        paragraphs.push(lang === 'en'
          ? 'I am processing your intent and preparing a tailored synthesis. Specify goals, constraints or audience — I will respond with structured guidance.'
          : 'Я анализирую намерение и готовлю точный синтез. Укажи цель, ограничения или аудиторию — отвечу структурированно.');
        break;
    }

    if (knowledge) {
      paragraphs.push(knowledge.detail[lang]);
    }

    const memoryNote = describeMemory(lang);
    if (memoryNote) {
      paragraphs.push(memoryNote);
    }

    const realtimeNote = summariseRealtime(lang);
    if (realtimeNote) {
      paragraphs.push(realtimeNote);
    }

    const baseSet = baseSuggestions[lang] || baseSuggestions.ru;
    const localeSuggestions = intentSuggestions[lang] || {};
    const suggestions = (localeSuggestions[intent] || baseSet).slice();

    return {
      text: paragraphs.join('\n\n'),
      intent,
      knowledge,
      suggestions
    };
  }

  function getInitialSuggestions(lang) {
    const locale = normaliseLang(lang);
    const baseSet = baseSuggestions[locale] || baseSuggestions.ru || [];
    return baseSet.slice();
  }

  function ingestRealtimeFact(channel, summary, payload = {}) {
    const normalizedSummary = typeof summary === 'object' && summary !== null
      ? summary
      : { ru: String(summary || ''), en: String(summary || '') };
    const entry = {
      id: `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`,
      timestamp: new Date().toISOString(),
      channel,
      summary: normalizedSummary,
      payload
    };
    state.stream.push(entry);
    if (state.stream.length > streamLimit) {
      state.stream.splice(0, state.stream.length - streamLimit);
    }
    persistStream();
    rebuildSummary();
    emitSnapshot();
    return entry;
  }

  function captureHeartbeat() {
    const now = new Date();
    const summary = {
      ru: `Пульс ядра ${formatDateTimeDisplay(now, 'ru')}. Система синхронизирует индексы памяти и потоков.`,
      en: `Core heartbeat ${formatDateTimeDisplay(now, 'en')}. System synchronises memory and stream indexes.`
    };
    ingestRealtimeFact('heartbeat', summary, { timestamp: now.toISOString() });
  }

  function respond(prompt, lang) {
    const locale = normaliseLang(lang);
    const result = buildResponse(prompt, locale);
    const entry = {
      timestamp: new Date().toISOString(),
      intent: result.intent,
      user: prompt,
      assistant: result.text,
      lang: locale
    };
    state.memory.push(entry);
    persistMemory();
    const keywords = normaliseKeywords(prompt).slice(0, 6);
    ingestRealtimeFact(
      'dialogue',
      {
        ru: `Обработан запрос пользователя с намерением «${result.intent}».` ,
        en: `Processed user request with intent “${result.intent}”.`
      },
      {
        intent: result.intent,
        lang: locale,
        keywords,
        length: prompt.length
      }
    );
    return new Promise((resolve) => {
      const delay = prefersReducedMotion ? 80 : 320 + Math.random() * 420;
      setTimeout(() => resolve(result), delay);
    });
  }

  function getIntro(lang) {
    const locale = normaliseLang(lang);
    const dictionary = getDictionary(locale);
    const fragmentsRestored = state.memory.length;
    return `${dictionary['ai.system.awake']} ${dictionary['ai.system.memoryRestored']}${fragmentsRestored}. ${dictionary['ai.system.newDialog']}`;
  }

  function getMemory() {
    return state.memory.slice(-memoryLimit);
  }

  function subscribe(listener) {
    if (typeof listener !== 'function') {
      return () => {};
    }
    const handler = (event) => {
      listener(event.detail);
    };
    eventTarget.addEventListener('update', handler);
    listener({
      memory: getMemory(),
      stream: getRealtimeFeed(),
      summary: getSummary()
    });
    return () => eventTarget.removeEventListener('update', handler);
  }

  return {
    respond,
    getIntro,
    getMemory,
    getInitialSuggestions,
    normaliseLang,
    ingestRealtimeFact,
    captureHeartbeat,
    subscribe,
    getRealtimeFeed,
    getSummary
  };
}

function createHyperNetOrchestrator(engine) {
  const neural = engine && typeof engine.ingestRealtimeFact === 'function' ? engine : null;
  const normaliseLang = engine && typeof engine.normaliseLang === 'function'
    ? (lang) => engine.normaliseLang(lang)
    : (lang) => (lang === 'en' ? 'en' : 'ru');
  const eventTarget = new EventTarget();
  const selection = new Set();
  const state = {
    query: '',
    filters: new Set(),
    results: [],
    log: [],
    status: 'idle',
    activeAction: 'digest'
  };

  const availableFilters = ['trends', 'infrastructure', 'markets', 'culture', 'research'];

  const hyperSources = [
    {
      id: 'quantum-observatory',
      priority: 1.4,
      tags: ['research', 'trends'],
      headline: {
        ru: 'Квантовая обсерватория выпускает карту новых интеллектуальных волн',
        en: 'Quantum observatory releases map of emerging intelligence waves'
      },
      summary: {
        ru: 'Орбитальная сеть спутников зафиксировала 38 всплесков когнитивной активности в мегаполисах.',
        en: 'The orbital satellite mesh recorded 38 spikes of cognitive activity across megacities.'
      },
      detail: {
        ru: 'По данным HyperNet, города-сфинксы вводят автономные кампусы для совместной работы людей и синтетических интеллектов.',
        en: 'HyperNet data shows sphinx cities launching autonomous campuses for human and synthetic intelligence co-creation.'
      },
      url: 'https://hyper.aksi/quantum-observatory',
      metrics: { freshness: 0.94, credibility: 0.88, amplitude: 0.72 }
    },
    {
      id: 'metacity-grid',
      priority: 1.25,
      tags: ['infrastructure', 'markets'],
      headline: {
        ru: 'Метагородская решётка открывает доступ к энергетическим коридорам',
        en: 'Metacity grid opens access to energy corridors'
      },
      summary: {
        ru: 'Система ультралинейных хабов снижает стоимость запуска цифровых производств на 27%.',
        en: 'A system of ultralinear hubs drops the cost of spinning up digital factories by 27%.'
      },
      detail: {
        ru: 'ООО «ЭЛЕКТРИК ПЛЮС» тестирует стеклянные подстанции с самоохлаждением и встроенным ИИ-мониторингом.',
        en: 'OOO Elektrik Plus pilots self-cooled glass substations with embedded AI monitoring.'
      },
      url: 'https://hyper.aksi/metacity-grid',
      metrics: { freshness: 0.86, credibility: 0.91, amplitude: 0.81 }
    },
    {
      id: 'culture-field',
      priority: 1.12,
      tags: ['culture', 'trends'],
      headline: {
        ru: 'Культурные поля обучают синтетические эмоции для публичных сервисов',
        en: 'Culture fields train synthetic emotions for public services'
      },
      summary: {
        ru: 'Городские павильоны транслируют эмоциональные паттерны, чтобы улучшить ответы автономных консультантов.',
        en: 'Urban pavilions broadcast emotional patterns to refine autonomous consultant responses.'
      },
      detail: {
        ru: 'HyperNet отмечает рост вовлечённости на 41% после внедрения эмоцио-графического интерфейса AKSI.',
        en: 'HyperNet notes a 41% engagement increase after introducing AKSI’s emotio-graphic interface.'
      },
      url: 'https://hyper.aksi/culture-field',
      metrics: { freshness: 0.79, credibility: 0.76, amplitude: 0.69 }
    },
    {
      id: 'energy-swarm',
      priority: 1.3,
      tags: ['infrastructure', 'research'],
      headline: {
        ru: 'Рой энергомодулей синхронизирует климатические купола',
        en: 'Energy swarm synchronises climate domes'
      },
      summary: {
        ru: 'Сотни модулей распределяют нагрузку и предотвращают перегрев умных кварталов.',
        en: 'Hundreds of modules balance the load and prevent smart districts from overheating.'
      },
      detail: {
        ru: 'Алгоритмы AKSI подстраивают частоту, чтобы сохранить комфорт жителей и снизить энергопотери.',
        en: 'AKSI algorithms tune the frequency to keep citizens comfortable while reducing energy loss.'
      },
      url: 'https://hyper.aksi/energy-swarm',
      metrics: { freshness: 0.91, credibility: 0.83, amplitude: 0.64 }
    },
    {
      id: 'market-singularity',
      priority: 1.22,
      tags: ['markets', 'trends'],
      headline: {
        ru: 'Рынки сингулярности сигнализируют о росте спроса на автономных советников',
        en: 'Singularity markets signal a surge in autonomous advisor demand'
      },
      summary: {
        ru: 'Платформы мегагородов заключают контракты на «ИИ-близнецов» для каждого стартапа.',
        en: 'Megacity platforms sign contracts for “AI twins” to accompany every startup.'
      },
      detail: {
        ru: 'HyperNet фиксирует рост инвестиций в секторе «безключевых» ИИ-интерфейсов на 61% за квартал.',
        en: 'HyperNet detects a 61% quarterly investment growth in “keyless” AI interfaces.'
      },
      url: 'https://hyper.aksi/market-singularity',
      metrics: { freshness: 0.84, credibility: 0.87, amplitude: 0.78 }
    },
    {
      id: 'civic-neural',
      priority: 1.18,
      tags: ['culture', 'infrastructure'],
      headline: {
        ru: 'Гражданская нейросеть переводит сервисы в режим «прозрачного участия»',
        en: 'Civic neural mesh shifts services to transparent participation mode'
      },
      summary: {
        ru: 'Жители управляют районами через голографические панели с обратной связью в реальном времени.',
        en: 'Citizens steer districts via holographic panels with realtime feedback.'
      },
      detail: {
        ru: 'Система памяти AKSI сохраняет инициативы и связывает их с потоками бюджета и инфраструктуры.',
        en: 'AKSI’s memory binds civic initiatives to budget and infrastructure streams.'
      },
      url: 'https://hyper.aksi/civic-neural',
      metrics: { freshness: 0.75, credibility: 0.89, amplitude: 0.73 }
    },
    {
      id: 'sustain-lab',
      priority: 1.15,
      tags: ['research', 'markets'],
      headline: {
        ru: 'Лаборатории устойчивости строят био-сенсоры на базе AKSI',
        en: 'Sustainability labs build bio-sensors on top of AKSI'
      },
      summary: {
        ru: 'Агрегаторы экологических данных переходят на автономную интерпретацию сигналов.',
        en: 'Environmental aggregators move toward autonomous signal interpretation.'
      },
      detail: {
        ru: 'HyperNet указывает на снижение времени реакции команд на 48 минут за счёт локальных моделей.',
        en: 'HyperNet reports reaction times dropping by 48 minutes thanks to local models.'
      },
      url: 'https://hyper.aksi/sustain-lab',
      metrics: { freshness: 0.82, credibility: 0.86, amplitude: 0.58 }
    },
    {
      id: 'aerial-index',
      priority: 1.08,
      tags: ['trends', 'culture'],
      headline: {
        ru: 'Аэроиндекс фиксирует настроение городов по световым потокам',
        en: 'Aerial index captures city mood through light flows'
      },
      summary: {
        ru: 'Дроны HyperNet анализируют интенсивность неона и звуковые паттерны, прогнозируя спрос на сервисы.',
        en: 'HyperNet drones analyse neon intensity and sonic patterns to forecast service demand.'
      },
      detail: {
        ru: 'Панорамы превращаются в дашборды, которые подсказывают, какие сценарии AKSI запустить в районах.',
        en: 'City panoramas become dashboards guiding which AKSI scenarios to deploy in each district.'
      },
      url: 'https://hyper.aksi/aerial-index',
      metrics: { freshness: 0.77, credibility: 0.74, amplitude: 0.9 }
    }
  ];

  const hyperActions = [
    {
      id: 'digest',
      label: {
        ru: 'Квантовый дайджест',
        en: 'Quantum digest'
      },
      description: {
        ru: 'Собирает ключевые сигналы и превращает их в сжатый отчёт.',
        en: 'Collects the leading signals and distils them into a compact report.'
      },
      execute({ results, query, filters }) {
        const top = results.slice(0, 3);
        const count = top.length;
        const label = query || 'HyperNet';
        const filterLabel = filters.length ? filters.join(', ') : 'all channels';
        return {
          log: {
            ru: `Собран квантовый дайджест: ${count} сигнала для «${label}».`,
            en: `Quantum digest compiled: ${count} signals for “${label}”.`
          },
          detail: {
            ru: top.map((entry) => `${entry.source.headline.ru} — ${Math.round(entry.relevance)}%`),
            en: top.map((entry) => `${entry.source.headline.en} — ${Math.round(entry.relevance)}%`)
          },
          stream: {
            ru: `HyperNet: дайджест завершён, активные каналы — ${filterLabel}.`,
            en: `HyperNet: digest ready, active channels — ${filterLabel}.`
          }
        };
      }
    },
    {
      id: 'pulse',
      label: {
        ru: 'Импульс возможностей',
        en: 'Opportunity pulse'
      },
      description: {
        ru: 'Расставляет приоритеты и формирует окно возможностей на основе выбранных источников.',
        en: 'Ranks priorities and maps the opportunity window based on the selected sources.'
      },
      execute({ results, query }) {
        const window = results.slice(0, 4);
        const label = query || 'HyperNet';
        const detailRu = window.map((entry) => `• ${entry.source.headline.ru} → индекс ${Math.round(entry.relevance)}`);
        const detailEn = window.map((entry) => `• ${entry.source.headline.en} → index ${Math.round(entry.relevance)}`);
        return {
          log: {
            ru: `Импульс сформирован: ${window.length} направлений для «${label}».`,
            en: `Pulse locked: ${window.length} lanes for “${label}”.`
          },
          detail: { ru: detailRu, en: detailEn },
          stream: {
            ru: 'HyperNet: возможности ранжированы, окно действий открыто.',
            en: 'HyperNet: opportunities prioritised, action window open.'
          }
        };
      }
    },
    {
      id: 'deploy',
      label: {
        ru: 'Пакет действий',
        en: 'Action package'
      },
      description: {
        ru: 'Строит пошаговый план действий и назначает виртуальных агентов.',
        en: 'Builds a stepwise plan and assigns virtual agents.'
      },
      execute({ results }) {
        const mission = results.slice(0, 3);
        const detailRu = mission.map((entry, index) => `${index + 1}. ${entry.source.headline.ru}`);
        const detailEn = mission.map((entry, index) => `${index + 1}. ${entry.source.headline.en}`);
        return {
          log: {
            ru: `Пакет действий готов: ${mission.length} шага синхронизированы с агентами.`,
            en: `Action package ready: ${mission.length} stages synchronised with agents.`
          },
          detail: { ru: detailRu, en: detailEn },
          stream: {
            ru: 'HyperNet: агенты назначены, последовательность исполнения отправлена.',
            en: 'HyperNet: agents assigned, execution sequence dispatched.'
          }
        };
      }
    }
  ];

  function normaliseTokens(text) {
    if (!text) return [];
    return String(text)
      .toLowerCase()
      .replace(/[^\p{L}\p{N}\s]+/gu, ' ')
      .split(/\s+/)
      .filter((token) => token.length > 2);
  }

  function uniqueTokens(tokens) {
    return Array.from(new Set(tokens));
  }

  function escapeRegExp(value) {
    return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  function highlightText(text, tokens) {
    if (!text) return '';
    if (!tokens || !tokens.length) return text;
    const pattern = tokens.map((token) => escapeRegExp(token)).join('|');
    if (!pattern) return text;
    const regex = new RegExp(`(${pattern})`, 'giu');
    return text.replace(regex, '<mark>$1</mark>');
  }

  function buildVectors() {
    hyperSources.forEach((source) => {
      const combined = [
        source.id,
        ...(source.tags || []),
        source.headline?.ru,
        source.headline?.en,
        source.summary?.ru,
        source.summary?.en,
        source.detail?.ru,
        source.detail?.en
      ]
        .filter(Boolean)
        .join(' ');
      source.vector = uniqueTokens(normaliseTokens(combined));
    });
  }

  buildVectors();

  function evaluateSource(vector, tokens, filterSet, source) {
    let score = (source.priority || 1) * 1.2;
    let matches = 0;
    tokens.forEach((token) => {
      if (vector.includes(token)) {
        matches += 1;
        score += 2.6;
      } else {
        const partial = vector.find((item) => item.startsWith(token.slice(0, 4)));
        if (partial) {
          matches += 0.5;
          score += 1.1;
        }
      }
    });
    if (!tokens.length) {
      score += 1.6;
    }
    if (filterSet.size) {
      const overlap = source.tags.filter((tag) => filterSet.has(tag)).length;
      if (overlap) {
        score += overlap * 1.4;
      } else {
        score *= 0.42;
      }
    }
    return { score, matches };
  }

  function pushLog(type, text, detail) {
    const entry = {
      id: `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 6)}`,
      timestamp: new Date().toISOString(),
      type,
      text,
      detail: detail || null
    };
    state.log.unshift(entry);
    if (state.log.length > 14) {
      state.log.length = 14;
    }
  }

  function getSnapshot() {
    return {
      query: state.query,
      filters: Array.from(state.filters),
      results: state.results.map((result) => ({
        ...result,
        selected: selection.has(result.id)
      })),
      log: state.log.slice(),
      status: state.status,
      activeAction: state.activeAction,
      actions: hyperActions.map((action) => ({
        id: action.id,
        label: action.label,
        description: action.description,
        active: state.activeAction === action.id
      }))
    };
  }

  function emit() {
    eventTarget.dispatchEvent(new CustomEvent('update', { detail: getSnapshot() }));
  }

  function search(query, filters, lang = 'ru') {
    const filterArray = Array.isArray(filters)
      ? filters.filter((value) => availableFilters.includes(value))
      : Array.from(filters instanceof Set ? filters : state.filters).filter((value) => availableFilters.includes(value));
    const filterSet = new Set(filterArray);
    state.filters = filterSet;
    state.query = query || '';
    state.status = 'scanning';
    emit();

    const tokens = uniqueTokens(normaliseTokens(state.query));
    const computed = hyperSources.map((source) => {
      const { score, matches } = evaluateSource(source.vector || [], tokens, filterSet, source);
      return { source, score, matches };
    });

    const trimmed = computed
      .filter((entry) => entry.score > (tokens.length ? 0.45 : 0.25))
      .sort((a, b) => b.score - a.score)
      .slice(0, 8)
      .map((entry, index) => {
        const highlight = {
          ru: highlightText(entry.source.summary?.ru || '', tokens),
          en: highlightText(entry.source.summary?.en || '', tokens)
        };
        const detailHighlight = {
          ru: highlightText(entry.source.detail?.ru || '', tokens),
          en: highlightText(entry.source.detail?.en || '', tokens)
        };
        return {
          id: entry.source.id,
          rank: index + 1,
          score: Number(entry.score.toFixed(3)),
          matches: entry.matches,
          relevance: Math.min(100, Math.round(entry.score * 14 + entry.matches * 6)),
          highlight,
          detailHighlight,
          source: entry.source,
          metrics: entry.source.metrics || { freshness: 0, credibility: 0, amplitude: 0 },
          tags: entry.source.tags || [],
          url: entry.source.url
        };
      });

    state.results = trimmed;
    selection.clear();
    state.results.slice(0, Math.min(3, state.results.length)).forEach((result) => selection.add(result.id));
    state.status = 'ready';

    const summaryRu = `HyperNet синхронизирована: найдено ${state.results.length} сигналов.`;
    const summaryEn = `HyperNet synchronised: ${state.results.length} signals surfaced.`;
    const detail = {
      ru: state.results.slice(0, 4).map((result) => `${result.source.headline.ru} (${Math.round(result.relevance)}%)`),
      en: state.results.slice(0, 4).map((result) => `${result.source.headline.en} (${Math.round(result.relevance)}%)`)
    };
    pushLog('search', { ru: summaryRu, en: summaryEn }, detail);

    if (neural) {
      neural.ingestRealtimeFact(
        'external',
        {
          ru: `HyperNet отчёт: ${state.results.length} сигналов для «${state.query || 'глобальный обзор'}».`,
          en: `HyperNet report: ${state.results.length} signals for “${state.query || 'global overview'}”.`
        },
        {
          query: state.query,
          filters: Array.from(filterSet),
          results: state.results.slice(0, 5).map((result) => ({
            id: result.id,
            relevance: result.relevance,
            tags: result.tags
          }))
        }
      );
    }

    emit();
  }

  function setFilters(filters, lang = 'ru') {
    const values = Array.isArray(filters) ? filters : Array.from(filters || []);
    const clean = values.filter((value) => availableFilters.includes(value));
    if (!state.query && !clean.length) {
      state.filters = new Set();
      emit();
      return;
    }
    search(state.query, new Set(clean), lang);
  }

  function toggleSelection(id) {
    if (!id) return;
    if (selection.has(id)) {
      selection.delete(id);
    } else {
      selection.add(id);
    }
    if (!selection.size && state.results.length) {
      selection.add(state.results[0].id);
    }
    emit();
  }

  function setActiveAction(id) {
    if (!hyperActions.find((action) => action.id === id)) return;
    state.activeAction = id;
    emit();
  }

  function runActiveAction(lang = 'ru') {
    const action = hyperActions.find((item) => item.id === state.activeAction);
    if (!action || !state.results.length) return Promise.resolve(null);
    const locale = normaliseLang(lang);
    const selected = state.results.filter((result) => selection.has(result.id));
    const pool = selected.length ? selected : state.results.slice(0, 3);
    state.status = 'executing';
    emit();
    return new Promise((resolve) => {
      const delay = prefersReducedMotion ? 120 : 540 + Math.random() * 360;
      setTimeout(() => {
        const output = action.execute({ results: pool, query: state.query, filters: Array.from(state.filters) });
        pushLog('action', output.log, output.detail);
        if (neural) {
          neural.ingestRealtimeFact(
            'external',
            {
              ru: output.stream?.ru || 'HyperNet: сценарий выполнен.',
              en: output.stream?.en || 'HyperNet: scenario executed.'
            },
            {
              action: action.id,
              selection: pool.map((item) => item.id),
              query: state.query
            }
          );
        }
        state.status = 'ready';
        emit();
        resolve({ ...output, locale });
      }, delay);
    });
  }

  function prime(lang = 'ru') {
    const locale = normaliseLang(lang);
    const defaults = {
      ru: 'интеллект будущего AKSI',
      en: 'AKSI future intelligence'
    };
    const seed = state.query || defaults[locale] || 'AKSI intelligence';
    search(seed, state.filters, locale);
  }

  function refresh() {
    emit();
  }

  function subscribe(listener) {
    if (typeof listener !== 'function') {
      return () => {};
    }
    const handler = (event) => listener(event.detail);
    eventTarget.addEventListener('update', handler);
    listener(getSnapshot());
    return () => eventTarget.removeEventListener('update', handler);
  }

  return {
    search,
    setFilters,
    toggleSelection,
    setActiveAction,
    runActiveAction,
    subscribe,
    prime,
    refresh,
    getState: getSnapshot
  };
}

function renderAiMessage(role, text, lang = 'ru') {
  const container = document.querySelector('[data-ai-messages]');
  if (!container) return;
  const message = document.createElement('div');
  message.className = `ai-message ${role}`;

  const avatar = document.createElement('div');
  avatar.className = 'ai-avatar';
  const locale = lang === 'en' ? 'en' : 'ru';
  if (role === 'user') {
    avatar.textContent = locale === 'en' ? 'YOU' : 'Я';
  } else if (role === 'system') {
    avatar.textContent = 'SYS';
  } else {
    avatar.textContent = 'AK';
  }

  const bubble = document.createElement('div');
  bubble.className = 'ai-bubble';

  text.split('\n\n').forEach((block) => {
    const paragraph = document.createElement('p');
    const lines = block.split('\n');
    lines.forEach((line, index) => {
      paragraph.appendChild(document.createTextNode(line));
      if (index < lines.length - 1) {
        paragraph.appendChild(document.createElement('br'));
      }
    });
    bubble.appendChild(paragraph);
  });

  message.appendChild(avatar);
  message.appendChild(bubble);
  container.appendChild(message);
  container.scrollTop = container.scrollHeight;
}

function renderAiTyping() {
  const container = document.querySelector('[data-ai-messages]');
  if (!container) return null;
  const typing = document.createElement('div');
  typing.className = 'ai-typing';
  typing.textContent = '…';
  container.appendChild(typing);
  container.scrollTop = container.scrollHeight;
  return typing;
}

function updateAiMemory(entries, lang = 'ru') {
  const memoryNode = document.querySelector('[data-ai-memory]');
  if (!memoryNode) return;
  memoryNode.innerHTML = '';
  const locale = lang === 'en' ? 'en' : 'ru';
  const dictionary = getDictionary(locale);
  if (!entries.length) {
    const empty = document.createElement('p');
    empty.dataset.i18n = 'ai.memory.empty';
    empty.textContent = dictionary['ai.memory.empty'];
    memoryNode.appendChild(empty);
    return;
  }
  entries.slice().reverse().forEach((entry) => {
    const wrapper = document.createElement('div');
    wrapper.className = 'ai-memory-entry';
    const ts = document.createElement('strong');
    ts.textContent = `${dictionary['ai.memory.timestamp']}: ${formatDateTimeDisplay(new Date(entry.timestamp), locale)}`;
    const intent = document.createElement('span');
    const intentLabel = dictionary['ai.memory.intent'];
    intent.textContent = `${intentLabel}: ${entry.intent}`;
    wrapper.appendChild(ts);
    wrapper.appendChild(intent);
    const summary = document.createElement('span');
    summary.textContent = entry.user;
    wrapper.appendChild(summary);
    memoryNode.appendChild(wrapper);
  });
}

function updateAiCapacity(summary, lang = 'ru') {
  const capacityNode = document.querySelector('[data-ai-capacity]');
  if (!capacityNode) return;
  const locale = lang === 'en' ? 'en' : 'ru';
  const formatter = new Intl.NumberFormat(locale === 'en' ? 'en-US' : 'ru-RU');
  const stats = summary?.stats || { fragments: 0, stream: 0, intents: 0, tokens: 0 };
  const mapping = [
    { key: 'ai.memory.capacityFragments', value: stats.fragments || 0 },
    { key: 'ai.memory.capacityStream', value: stats.stream || 0 },
    { key: 'ai.memory.capacityIntents', value: stats.intents || 0 },
    { key: 'ai.memory.capacityTokens', value: stats.tokens || 0 }
  ];
  mapping.forEach((item) => {
    const dt = capacityNode.querySelector(`dt[data-i18n="${item.key}"]`);
    if (!dt) return;
    const wrapper = dt.closest('div');
    const dd = wrapper ? wrapper.querySelector('dd') : null;
    if (dd) {
      dd.textContent = formatter.format(item.value);
    }
  });
}

function updateAiInsights(summary, lang = 'ru') {
  const container = document.querySelector('[data-ai-insights]');
  const meta = document.querySelector('[data-ai-insights-meta]');
  if (!container) return;
  const locale = lang === 'en' ? 'en' : 'ru';
  const dictionary = getDictionary(locale);
  container.innerHTML = '';
  const keywords = summary?.topKeywords || [];
  if (!keywords.length) {
    const empty = document.createElement('p');
    empty.dataset.i18n = 'ai.insights.empty';
    empty.textContent = dictionary['ai.insights.empty'];
    container.appendChild(empty);
  } else {
    keywords.forEach((item) => {
      const chip = document.createElement('span');
      chip.className = 'ai-insights-chip';
      const word = document.createElement('strong');
      word.textContent = item.word;
      chip.appendChild(word);
      const count = document.createElement('span');
      count.textContent = `×${item.count}`;
      chip.appendChild(count);
      container.appendChild(chip);
    });
  }
  if (meta) {
    if (summary?.lastUpdated) {
      meta.textContent = `${dictionary['ai.insights.updated']}: ${formatDateTimeDisplay(new Date(summary.lastUpdated), locale)}`;
    } else {
      meta.textContent = '';
    }
  }
}

function updateAiStream(entries, lang = 'ru') {
  const container = document.querySelector('[data-ai-stream]');
  if (!container) return;
  const locale = lang === 'en' ? 'en' : 'ru';
  const dictionary = getDictionary(locale);
  container.innerHTML = '';
  if (!entries.length) {
    const empty = document.createElement('p');
    empty.dataset.i18n = 'ai.stream.empty';
    empty.textContent = dictionary['ai.stream.empty'];
    container.appendChild(empty);
    return;
  }
  entries
    .slice()
    .reverse()
    .forEach((entry) => {
      const node = document.createElement('article');
      node.className = 'ai-stream-entry';
      const channel = document.createElement('span');
      channel.className = 'ai-stream-channel';
      const channelKey = `ai.stream.channel.${entry.channel}`;
      channel.textContent = dictionary[channelKey] || dictionary['ai.stream.channel.external'];
      node.appendChild(channel);
      const summary = document.createElement('p');
      summary.className = 'ai-stream-summary';
      summary.textContent = entry.summary?.[locale] || entry.summary?.ru || entry.summary?.en || '';
      node.appendChild(summary);
      const meta = document.createElement('span');
      meta.className = 'ai-stream-meta';
      meta.textContent = formatDateTimeDisplay(new Date(entry.timestamp), locale);
      node.appendChild(meta);
      container.appendChild(node);
    });
}

function renderAiSuggestions(suggestions, lang = 'ru') {
  const container = document.querySelector('[data-ai-suggestions]');
  if (!container) return;
  container.innerHTML = '';
  const list = Array.isArray(suggestions) ? suggestions : [];
  list.forEach((hint) => {
    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'ai-suggestion';
    button.textContent = hint;
    button.addEventListener('click', () => {
      const form = document.querySelector('[data-ai-form]');
      const input = form ? form.querySelector('input[name="prompt"]') : null;
      if (!form || !input) return;
      input.value = hint;
      if (typeof form.requestSubmit === 'function') {
        form.requestSubmit();
      } else {
        form.dispatchEvent(new Event('submit', { cancelable: true }));
      }
    });
    container.appendChild(button);
  });
}

function initRealtimeSensors(engine) {
  if (sensorsBootstrapped) return;
  if (!engine || typeof engine.ingestRealtimeFact !== 'function') return;
  sensorsBootstrapped = true;
  let pointerSamples = [];
  let lastPointer = null;
  let scrollSamples = [];
  let lastScroll = window.scrollY || 0;
  let lastScrollTime = performance.now();

  if (!prefersReducedMotion) {
    window.addEventListener('pointermove', (event) => {
      const now = performance.now();
      if (lastPointer) {
        const dx = event.clientX - lastPointer.x;
        const dy = event.clientY - lastPointer.y;
        const dt = Math.max(now - lastPointer.t, 1);
        const distance = Math.hypot(dx, dy);
        const speed = distance / dt;
        pointerSamples.push({ speed, distance, dx, dy });
        if (pointerSamples.length > 160) {
          pointerSamples.shift();
        }
      }
      lastPointer = { x: event.clientX, y: event.clientY, t: now };
    });

    window.setInterval(() => {
      if (!pointerSamples.length) return;
      const count = pointerSamples.length;
      const totalSpeed = pointerSamples.reduce((acc, sample) => acc + sample.speed, 0);
      const avgSpeed = totalSpeed / count;
      const totalDistance = pointerSamples.reduce((acc, sample) => acc + sample.distance, 0);
      const latest = pointerSamples[pointerSamples.length - 1] || { dx: 0, dy: 0 };
      const angle = Math.round((Math.atan2(latest.dy, latest.dx) * 180) / Math.PI);
      const intensity = Math.min(999, Math.round(avgSpeed * 120));
      engine.ingestRealtimeFact(
        'motion',
        {
          ru: `Движение курсора: интенсивность ${intensity}, дистанция ${Math.round(totalDistance)}px.` ,
          en: `Cursor motion intensity ${intensity}, distance ${Math.round(totalDistance)}px.`
        },
        {
          samples: count,
          intensity,
          distance: Math.round(totalDistance),
          angle
        }
      );
      pointerSamples = [];
    }, prefersReducedMotion ? 6000 : 3600);
  }

  window.addEventListener('scroll', () => {
    const now = performance.now();
    const delta = (window.scrollY || 0) - lastScroll;
    const dt = Math.max(now - lastScrollTime, 1);
    scrollSamples.push({ delta, velocity: Math.abs(delta) / dt });
    if (scrollSamples.length > 120) {
      scrollSamples.shift();
    }
    lastScroll = window.scrollY || 0;
    lastScrollTime = now;
  }, { passive: true });

  window.setInterval(() => {
    if (!scrollSamples.length) return;
    const count = scrollSamples.length;
    const totalDelta = scrollSamples.reduce((acc, sample) => acc + Math.abs(sample.delta), 0);
    const net = scrollSamples.reduce((acc, sample) => acc + sample.delta, 0);
    const velocity = scrollSamples.reduce((acc, sample) => acc + sample.velocity, 0) / count;
    engine.ingestRealtimeFact(
      'scroll',
      {
        ru: `Вертикальный сдвиг ${Math.round(net)}px, амплитуда ${Math.round(totalDelta)}px.` ,
        en: `Vertical shift ${Math.round(net)}px, amplitude ${Math.round(totalDelta)}px.`
      },
      {
        samples: count,
        amplitude: Math.round(totalDelta),
        net: Math.round(net),
        velocity: Number(velocity.toFixed(4))
      }
    );
    scrollSamples = [];
  }, prefersReducedMotion ? 7000 : 4200);

  window.setInterval(() => {
    if (typeof engine.captureHeartbeat === 'function') {
      engine.captureHeartbeat();
    }
  }, 20000);
}

function initAiConsole() {
  const form = document.querySelector('[data-ai-form]');
  const messages = document.querySelector('[data-ai-messages]');
  if (!form || !messages) return null;
  const engine = createAksiNeuralCore();
  let currentLang = document.documentElement.lang === 'en' ? 'en' : 'ru';
  initRealtimeSensors(engine);

  engine.subscribe((snapshot) => {
    updateAiMemory(snapshot.memory, currentLang);
    updateAiCapacity(snapshot.summary, currentLang);
    updateAiInsights(snapshot.summary, currentLang);
    updateAiStream(snapshot.stream, currentLang);
  });

  function setLocale(lang) {
    currentLang = engine.normaliseLang(lang);
    renderAiSuggestions(engine.getInitialSuggestions(currentLang), currentLang);
    const snapshot = {
      memory: engine.getMemory(),
      summary: engine.getSummary(),
      stream: engine.getRealtimeFeed()
    };
    updateAiMemory(snapshot.memory, currentLang);
    updateAiCapacity(snapshot.summary, currentLang);
    updateAiInsights(snapshot.summary, currentLang);
    updateAiStream(snapshot.stream, currentLang);
    const systemBubble = messages.querySelector('.ai-message.system .ai-bubble');
    if (systemBubble) {
      systemBubble.innerHTML = '';
      engine.getIntro(currentLang).split('\n\n').forEach((segment) => {
        const paragraph = document.createElement('p');
        paragraph.textContent = segment;
        systemBubble.appendChild(paragraph);
      });
    }
  }

  messages.innerHTML = '';
  renderAiMessage('system', engine.getIntro(currentLang), currentLang);
  setLocale(currentLang);
  engine.captureHeartbeat();

  const input = form.querySelector('input[name="prompt"]');
  const submitButton = form.querySelector('button[type="submit"]');

  form.addEventListener('submit', (event) => {
    event.preventDefault();
    if (!input) return;
    const value = input.value.trim();
    if (!value) return;
    renderAiMessage('user', value, currentLang);
    input.value = '';
    const typing = renderAiTyping();
    if (submitButton) submitButton.disabled = true;

    engine.respond(value, currentLang).then((payload) => {
      if (typing && typing.remove) typing.remove();
      renderAiMessage('assistant', payload.text, currentLang);
      renderAiSuggestions(payload.suggestions || engine.getInitialSuggestions(currentLang), currentLang);
    }).finally(() => {
      if (submitButton) submitButton.disabled = false;
      if (input) input.focus();
    });
  });

  document.addEventListener('aksi:language-changed', (event) => {
    const lang = event.detail?.lang;
    if (!lang) return;
    setLocale(lang);
  });

  return engine;
}

function initAksiLove(engine) {
  const stage = document.querySelector('[data-love-stage]');
  const overlay = document.querySelector('[data-love-overlay]');
  const launchers = Array.from(document.querySelectorAll('[data-love-launch]'));
  if (!stage && !overlay && !launchers.length) return;

  const planes = stage ? Array.from(stage.querySelectorAll('.love-plane')) : [];
  const closeTargets = overlay ? Array.from(overlay.querySelectorAll('[data-love-close]')) : [];
  const logNode = overlay ? overlay.querySelector('[data-love-log]') : null;
  const statusNode = overlay ? overlay.querySelector('[data-love-status]') : null;
  const suggestionsNode = overlay ? overlay.querySelector('[data-love-suggestions]') : null;
  const form = overlay ? overlay.querySelector('[data-love-form]') : null;
  const input = form ? form.querySelector('input[name="prompt"]') : null;
  const submitButton = form ? form.querySelector('button[type="submit"]') : null;

  let currentLang = document.documentElement.lang === 'en' ? 'en' : 'ru';
  let statusKey = 'idle';
  let overlayVisible = false;
  let typingNode = null;

  function getDictionaryForCurrentLang() {
    return getDictionary(currentLang);
  }

  function setStatus(key) {
    statusKey = key;
    if (!statusNode) return;
    const dictionary = getDictionaryForCurrentLang();
    statusNode.textContent = dictionary[`love.overlay.status.${key}`] || '';
  }

  function clearTyping() {
    if (typingNode && typingNode.remove) {
      typingNode.remove();
    }
    typingNode = null;
  }

  function showTyping() {
    if (!logNode) return null;
    const node = document.createElement('div');
    node.className = 'love-log-typing';
    node.textContent = '…';
    logNode.appendChild(node);
    logNode.scrollTop = logNode.scrollHeight;
    return node;
  }

  function appendLog(role, text) {
    if (!logNode) return;
    const entry = document.createElement('div');
    entry.className = `love-log-entry ${role}`;
    String(text || '')
      .split('\n\n')
      .forEach((block) => {
        if (!block) return;
        const paragraph = document.createElement('p');
        const lines = block.split('\n');
        lines.forEach((line, index) => {
          paragraph.appendChild(document.createTextNode(line));
          if (index < lines.length - 1) {
            paragraph.appendChild(document.createElement('br'));
          }
        });
        entry.appendChild(paragraph);
      });
    logNode.appendChild(entry);
    logNode.scrollTop = logNode.scrollHeight;
  }

  function renderLoveSuggestions(suggestions) {
    if (!suggestionsNode) return;
    suggestionsNode.innerHTML = '';
    if (!Array.isArray(suggestions) || !suggestions.length) {
      return;
    }
    suggestions.slice(0, 4).forEach((hint) => {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'love-suggestion';
      button.textContent = hint;
      button.addEventListener('click', () => {
        if (!form || !input) return;
        input.value = hint;
        if (typeof form.requestSubmit === 'function') {
          form.requestSubmit();
        } else {
          form.dispatchEvent(new Event('submit', { cancelable: true }));
        }
      });
      suggestionsNode.appendChild(button);
    });
  }

  function runLaunchSequence() {
    if (logNode) {
      logNode.innerHTML = '';
    }
    const dictionary = getDictionaryForCurrentLang();
    appendLog('system', dictionary['love.overlay.welcome']);
    renderLoveSuggestions(
      engine && typeof engine.getInitialSuggestions === 'function'
        ? engine.getInitialSuggestions(currentLang)
        : null
    );
    setStatus('sync');
    if (engine && typeof engine.respond === 'function') {
      const prompt = dictionary['love.overlay.autoprompt'];
      appendLog('user', prompt);
      typingNode = showTyping();
      setStatus('answer');
      if (submitButton) submitButton.disabled = true;
      engine.respond(prompt, currentLang)
        .then((payload) => {
          clearTyping();
          appendLog('assistant', payload?.text || '');
          renderLoveSuggestions(
            Array.isArray(payload?.suggestions) && payload.suggestions.length
              ? payload.suggestions
              : engine.getInitialSuggestions(currentLang)
          );
        })
        .catch(() => {
          clearTyping();
          appendLog('assistant', dictionary['love.overlay.fallback']);
        })
        .finally(() => {
          setStatus('idle');
          if (submitButton) submitButton.disabled = false;
        });
    } else {
      appendLog('assistant', dictionary['love.overlay.fallback']);
      setStatus('idle');
    }
  }

  function openOverlay() {
    if (!overlay) return;
    overlay.classList.add('is-visible');
    overlay.setAttribute('aria-hidden', 'false');
    document.body.classList.add('love-overlay-open');
    overlayVisible = true;
    runLaunchSequence();
    if (input) {
      setTimeout(() => input.focus(), prefersReducedMotion ? 0 : 300);
    }
  }

  function closeOverlay() {
    if (!overlay) return;
    overlay.classList.remove('is-visible');
    overlay.setAttribute('aria-hidden', 'true');
    document.body.classList.remove('love-overlay-open');
    overlayVisible = false;
    clearTyping();
  }

  function updateLocale(lang) {
    currentLang = lang === 'en' ? 'en' : 'ru';
    const dictionary = getDictionaryForCurrentLang();
    if (input && dictionary['love.overlay.placeholder']) {
      input.setAttribute('placeholder', dictionary['love.overlay.placeholder']);
    }
    setStatus(statusKey);
    if (!overlayVisible) {
      renderLoveSuggestions(
        engine && typeof engine.getInitialSuggestions === 'function'
          ? engine.getInitialSuggestions(currentLang)
          : null
      );
    }
  }

  if (form) {
    form.addEventListener('submit', (event) => {
      event.preventDefault();
      if (!input) return;
      const value = input.value.trim();
      if (!value) return;
      const dictionary = getDictionaryForCurrentLang();
      appendLog('user', value);
      input.value = '';
      if (!(engine && typeof engine.respond === 'function')) {
        appendLog('assistant', dictionary['love.overlay.fallback']);
        setStatus('idle');
        return;
      }
      const typing = showTyping();
      setStatus('answer');
      if (submitButton) submitButton.disabled = true;
      engine.respond(value, currentLang)
        .then((payload) => {
          if (typing && typing.remove) typing.remove();
          appendLog('assistant', payload?.text || '');
          renderLoveSuggestions(
            Array.isArray(payload?.suggestions) && payload.suggestions.length
              ? payload.suggestions
              : engine.getInitialSuggestions(currentLang)
          );
        })
        .catch(() => {
          if (typing && typing.remove) typing.remove();
          appendLog('assistant', dictionary['love.overlay.fallback']);
        })
        .finally(() => {
          setStatus('idle');
          if (submitButton) submitButton.disabled = false;
          if (input) input.focus();
        });
    });
  }

  launchers.forEach((button) => {
    button.addEventListener('click', () => {
      openOverlay();
    });
  });

  closeTargets.forEach((node) => {
    node.addEventListener('click', () => {
      closeOverlay();
    });
  });

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape' && overlayVisible) {
      event.preventDefault();
      closeOverlay();
    }
  });

  if (stage) {
    const applyParallax = (x, y) => {
      const rect = stage.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const normX = rect.width ? (x - centerX) / rect.width : 0;
      const normY = rect.height ? (y - centerY) / rect.height : 0;
      planes.forEach((plane) => {
        const depth = parseFloat(plane.dataset.depth || '1');
        const offsetX = normX * 160 * depth;
        const offsetY = normY * -140 * depth;
        const rotateZ = normX * 22 * depth;
        plane.style.setProperty('--offsetX', `${offsetX}px`);
        plane.style.setProperty('--offsetY', `${offsetY}px`);
        plane.style.setProperty('--rotateZ', `${rotateZ}deg`);
      });
      stage.style.setProperty('--glowX', `${normX * 40}px`);
      stage.style.setProperty('--glowY', `${normY * -40}px`);
    };

    const updateScroll = () => {
      const rect = stage.getBoundingClientRect();
      const viewport = window.innerHeight || document.documentElement.clientHeight || 1;
      const progress = Math.max(0, Math.min(1, 1 - (rect.top + rect.height) / (viewport + rect.height)));
      stage.style.setProperty('--scrollProgress', progress.toFixed(3));
      planes.forEach((plane, index) => {
        const depth = parseFloat(plane.dataset.depth || '1');
        const rotateX = (progress * 60 - 30) * depth + index * 3;
        plane.style.setProperty('--rotateX', `${rotateX}deg`);
      });
    };

    if (!prefersReducedMotion) {
      stage.addEventListener('pointermove', (event) => {
        applyParallax(event.clientX, event.clientY);
      });
      stage.addEventListener('pointerleave', () => {
        applyParallax(window.innerWidth / 2, window.innerHeight / 2);
      });
      window.addEventListener('scroll', () => {
        window.requestAnimationFrame(updateScroll);
      });
    }

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        stage.classList.toggle('is-active', entry.isIntersecting);
      });
    }, { threshold: 0.28 });
    observer.observe(stage);

    applyParallax(window.innerWidth / 2, window.innerHeight / 2);
    updateScroll();
  }

  document.addEventListener('aksi:language-changed', (event) => {
    const lang = event.detail?.lang;
    if (!lang) return;
    updateLocale(lang);
    if (overlayVisible) {
      runLaunchSequence();
    }
  });

  updateLocale(currentLang);
  setStatus('idle');
}

function initHyperNet(engine) {
  const form = document.querySelector('[data-hypernet-form]');
  const queryInput = form ? form.querySelector('[data-hypernet-query]') : null;
  const summaryNode = document.querySelector('[data-hypernet-summary]');
  const resultsNode = document.querySelector('[data-hypernet-results]');
  const actionsNode = document.querySelector('[data-hypernet-actions]');
  const logNode = document.querySelector('[data-hypernet-log]');
  const statusNode = document.querySelector('[data-hypernet-status]');
  const runButton = document.querySelector('[data-hypernet-run]');
  const filterNodes = Array.from(document.querySelectorAll('[data-hypernet-filter]'));
  if (!form || !resultsNode || !actionsNode || !logNode) return;

  const orchestrator = createHyperNetOrchestrator(engine);
  let currentLang = document.documentElement.lang === 'en' ? 'en' : 'ru';

  function getDictionaryForCurrentLang() {
    return getDictionary(currentLang);
  }

  function getActiveFilters() {
    return filterNodes.filter((node) => node.checked).map((node) => node.value);
  }

  function render(snapshot) {
    const dictionary = getDictionaryForCurrentLang();
    if (statusNode) {
      statusNode.dataset.state = snapshot.status;
      statusNode.classList.toggle('is-busy', snapshot.status === 'scanning' || snapshot.status === 'executing');
      const label = dictionary[`hypernet.status.${snapshot.status}`] || '';
      const strong = statusNode.querySelector('strong');
      if (strong) {
        strong.textContent = label;
      }
    }

    if (summaryNode) {
      const total = dictionary['hypernet.summary.total'].replace('{count}', snapshot.results.length);
      const selectedCount = snapshot.results.filter((result) => result.selected).length;
      const selected = dictionary['hypernet.summary.selected'].replace('{count}', selectedCount);
      const filters = snapshot.filters.length
        ? dictionary['hypernet.summary.filters.active'].replace(
            '{filters}',
            snapshot.filters
              .map((filter) => dictionary[`hypernet.filters.${filter}`] || filter)
              .join(', ')
          )
        : dictionary['hypernet.summary.filters.none'];
      summaryNode.innerHTML = '';
      [total, selected, filters].forEach((line) => {
        const span = document.createElement('span');
        span.textContent = line;
        summaryNode.appendChild(span);
      });
    }

    if (queryInput && document.activeElement !== queryInput) {
      queryInput.value = snapshot.query || '';
    }

    filterNodes.forEach((node) => {
      node.checked = snapshot.filters.includes(node.value);
    });

    resultsNode.innerHTML = '';
    if (!snapshot.results.length) {
      const empty = document.createElement('p');
      empty.textContent = dictionary['hypernet.results.empty'];
      resultsNode.appendChild(empty);
    } else {
      snapshot.results.forEach((result) => {
        const card = document.createElement('article');
        card.className = `hypernet-result${result.selected ? ' is-selected' : ''}`;
        card.dataset.resultId = result.id;

        const header = document.createElement('header');
        header.className = 'hypernet-result-header';

        const rank = document.createElement('span');
        rank.className = 'hypernet-result-rank';
        rank.textContent = result.rank.toString().padStart(2, '0');
        header.appendChild(rank);

        const titles = document.createElement('div');
        titles.className = 'hypernet-result-titles';
        const headline = document.createElement('h4');
        headline.textContent = result.source.headline[currentLang];
        titles.appendChild(headline);
        const url = document.createElement('span');
        url.className = 'hypernet-result-url';
        url.textContent = (result.url || '').replace(/^https?:\/\//, '');
        titles.appendChild(url);
        header.appendChild(titles);

        const score = document.createElement('span');
        score.className = 'hypernet-result-score';
        score.textContent = `${result.relevance}%`;
        header.appendChild(score);

        card.appendChild(header);

        const summary = document.createElement('p');
        summary.className = 'hypernet-result-summary';
        summary.innerHTML = result.highlight[currentLang] || result.source.summary[currentLang];
        card.appendChild(summary);

        const detail = document.createElement('p');
        detail.className = 'hypernet-result-detail';
        detail.innerHTML = result.detailHighlight[currentLang] || result.source.detail[currentLang];
        card.appendChild(detail);

        const tags = document.createElement('div');
        tags.className = 'hypernet-result-tags';
        result.tags.forEach((tag) => {
          const chip = document.createElement('span');
          chip.textContent = dictionary[`hypernet.filters.${tag}`] || tag;
          tags.appendChild(chip);
        });
        card.appendChild(tags);

        const metrics = document.createElement('div');
        metrics.className = 'hypernet-result-metrics';
        const metricConfig = [
          { key: 'hypernet.metric.freshness', value: result.metrics?.freshness || 0 },
          { key: 'hypernet.metric.credibility', value: result.metrics?.credibility || 0 },
          { key: 'hypernet.metric.amplitude', value: result.metrics?.amplitude || 0 }
        ];
        metricConfig.forEach((item) => {
          const row = document.createElement('div');
          row.className = 'hypernet-metric';
          const label = document.createElement('span');
          label.textContent = dictionary[item.key] || item.key;
          row.appendChild(label);
          const meter = document.createElement('div');
          meter.className = 'hypernet-meter';
          const fill = document.createElement('span');
          fill.style.width = `${Math.round(item.value * 100)}%`;
          meter.appendChild(fill);
          row.appendChild(meter);
          metrics.appendChild(row);
        });
        card.appendChild(metrics);

        resultsNode.appendChild(card);
      });
    }

    actionsNode.innerHTML = '';
    snapshot.actions.forEach((action) => {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = `hypernet-action${action.active ? ' is-active' : ''}`;
      button.dataset.actionId = action.id;
      const title = document.createElement('strong');
      title.textContent = action.label[currentLang];
      button.appendChild(title);
      const description = document.createElement('span');
      description.textContent = action.description[currentLang];
      button.appendChild(description);
      actionsNode.appendChild(button);
    });

    if (runButton) {
      const activeAction = snapshot.actions.find((action) => action.active);
      const baseLabel = dictionary['hypernet.actions.run'];
      runButton.textContent = activeAction ? `${baseLabel} · ${activeAction.label[currentLang]}` : baseLabel;
      runButton.disabled = snapshot.status === 'executing' || !snapshot.results.length;
    }

    logNode.innerHTML = '';
    if (!snapshot.log.length) {
      const empty = document.createElement('p');
      empty.textContent = dictionary['hypernet.log.empty'];
      logNode.appendChild(empty);
    } else {
      snapshot.log.forEach((entry) => {
        const item = document.createElement('article');
        item.className = `hypernet-log-entry ${entry.type}`;
        const time = document.createElement('time');
        time.dateTime = entry.timestamp;
        time.textContent = formatDateTimeDisplay(new Date(entry.timestamp), currentLang);
        item.appendChild(time);
        const summary = document.createElement('p');
        summary.textContent = entry.text[currentLang] || '';
        item.appendChild(summary);
        const details = entry.detail?.[currentLang];
        if (Array.isArray(details) && details.length) {
          const list = document.createElement('ul');
          details.forEach((line) => {
            const li = document.createElement('li');
            li.textContent = line;
            list.appendChild(li);
          });
          item.appendChild(list);
        }
        logNode.appendChild(item);
      });
    }
  }

  orchestrator.subscribe(render);

  form.addEventListener('submit', (event) => {
    event.preventDefault();
    const query = queryInput ? queryInput.value.trim() : '';
    orchestrator.search(query, getActiveFilters(), currentLang);
  });

  filterNodes.forEach((checkbox) => {
    checkbox.addEventListener('change', () => {
      orchestrator.setFilters(getActiveFilters(), currentLang);
    });
  });

  resultsNode.addEventListener('click', (event) => {
    const card = event.target.closest('[data-result-id]');
    if (!card) return;
    orchestrator.toggleSelection(card.dataset.resultId);
  });

  actionsNode.addEventListener('click', (event) => {
    const button = event.target.closest('[data-action-id]');
    if (!button) return;
    orchestrator.setActiveAction(button.dataset.actionId);
  });

  if (runButton) {
    runButton.addEventListener('click', () => {
      if (runButton.disabled) return;
      orchestrator.runActiveAction(currentLang);
    });
  }

  document.addEventListener('aksi:language-changed', (event) => {
    const lang = event.detail?.lang;
    if (!lang) return;
    currentLang = lang === 'en' ? 'en' : 'ru';
    orchestrator.refresh();
  });

  orchestrator.prime(currentLang);
}

function boot() {
  initLanguage();
  initFragments();
  initTilt();
  initScrollDepth();
  initCta();
  const engine = initAiConsole();
  initAksiLove(engine);
  initHyperNet(engine);
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', boot);
} else {
  boot();
}
