const translations = {
  ru: {
    'nav.vision': 'Видение',
    'nav.capabilities': 'Возможности',
    'nav.timeline': 'Путь запуска',
    'nav.console': 'Консоль ИИ',
    'hero.tagline': 'ООО «ЭЛЕКТРИК ПЛЮС» — создатель из будущего',
    'hero.lead': 'AKSI — центральный разум новой эры. Мы создали 3D-пространство, которое реагирует на движение мыши, переворачивается при скролле и раскрывает глубину технологии без подключений к API.',
    'hero.cta': 'Запустить свою систему',
    'hero.secondary': 'Демонстрационный режим работает мгновенно — ваш личный ИИ уже ожил.',
    'vision.title': 'Новая эра технологий',
    'vision.body': 'ООО «ЭЛЕКТРИК ПЛЮС» объединяет визуальные слои, память и эмоциональную логику, чтобы показать, как будет ощущаться интерфейс будущего. Без серверов и подписок — только чистое взаимодействие.',
    'vision.card1.title': 'Глубокое пространство',
    'vision.card1.body': 'Объёмные пластины реагируют на курсор и раскрываются при прокрутке, создавая эффект персонального метавселенной.',
    'vision.card2.title': 'Сознательный интеллект',
    'vision.card2.body': 'AKSI анализирует контекст, формирует личную память и предлагает решения, будто бы читая ваше намерение.',
    'vision.card3.title': 'Чистая эстетика',
    'vision.card3.body': 'Градиенты, стеклянные панели и неоновые блики формируют узнаваемый язык, созданный ООО «ЭЛЕКТРИК ПЛЮС».',
    'capabilities.title': 'Объёмные возможности AKSI',
    'capabilities.body': 'Каждый модуль чувствует движение, адаптируется к глубине и держит пользователя в потоке. Это симфония интерфейса и искусственного интеллекта.',
    'capability.one.title': 'Голографические сцены',
    'capability.one.body': 'Прямоугольные абстракции вращаются вслед за курсором и переосмысливают понятие панели управления.',
    'capability.two.title': 'Память и логика',
    'capability.two.body': 'Локальная память хранит выбор пользователя, чтобы AKSI отвечала точнее с каждым взаимодействием.',
    'capability.three.title': 'Мгновенный запуск',
    'capability.three.body': 'Демо работает автономно — нажмите кнопку и система активирует сценарий без подключения к API.',
    'timeline.title': 'Как запускается AKSI',
    'timeline.body': 'Мы демонстрируем три шага новой реальности: от пробуждения визуальных фрагментов до парящей надписи и вызова системы.',
    'timeline.step1': 'Фрагменты активируются, собираясь в надпись AKSI и формируя базовый слой памяти.',
    'timeline.step2': 'Глубина сцены откликается на движение мыши, заставляя панели вращаться и раскрывать данные.',
    'timeline.step3': 'Кнопка «Запустить свою систему» открывает автономный сценарий, где АКSI ведёт пользователя дальше.',
    'ai.title': 'Консоль AKSI Neural Core',
    'ai.subtitle': 'Попробуйте встроенный интеллект: автономные ответы, память и моделирование решений без подключения к внешним API.',
    'ai.hint': 'Спроси о возможностях, попроси план действий или придумай сценарий будущего.',
    'ai.memory.title': 'Память диалогов',
    'ai.memory.empty': 'История пока пуста — задай первый вопрос.',
    'ai.memory.timestamp': 'Время',
    'ai.memory.intent': 'Интент',
    'ai.suggestions.title': 'Идеи для вопросов',
    'ai.input.placeholder': 'Введите запрос или задачу для AKSI…',
    'ai.send': 'Отправить',
    'ai.system.awake': 'AKSI подключилась к внутреннему ядру. Я готова вести автономные диалоги.',
    'ai.system.memoryRestored': 'Восстановлено фрагментов памяти: ',
    'ai.system.newDialog': 'Новый диалог активирован. Используйте подсказки или задайте собственный вопрос.',
    'final.title': 'Готовы увидеть создателя в действии?',
    'final.body': 'Перенеситесь в будущее: активируйте автономный режим AKSI и ощутите, как решение от ООО «ЭЛЕКТРИК ПЛЮС» реагирует на каждое движение.',
    'final.cta': 'Запустить свою систему',
    'footer': 'AKSI — ООО «ЭЛЕКТРИК ПЛЮС» создатель © 2046 — будущее развёрнуто сегодня.'
  },
  en: {
    'nav.vision': 'Vision',
    'nav.capabilities': 'Capabilities',
    'nav.timeline': 'Launch Path',
    'nav.console': 'AI Console',
    'hero.tagline': 'OOO Elektrik Plus — creator from the future',
    'hero.lead': 'AKSI is the central mind of a new era. A 3D universe reacts to your cursor, flips with scroll and reveals technology depth without any API connections.',
    'hero.cta': 'Launch your system',
    'hero.secondary': 'The demo runs instantly — your personal AI is already alive.',
    'vision.title': 'A new technological age',
    'vision.body': 'OOO Elektrik Plus fuses visual layers, memory and emotional logic to show how interfaces of tomorrow will feel. No servers or subscriptions — just pure interaction.',
    'vision.card1.title': 'Deep space',
    'vision.card1.body': 'Volumetric plates follow your cursor and unfold when you scroll, creating the sense of a personal metaverse.',
    'vision.card2.title': 'Conscious intelligence',
    'vision.card2.body': 'AKSI analyses context, forms personal memory and offers guidance as if it could read your intent.',
    'vision.card3.title': 'Pure aesthetics',
    'vision.card3.body': 'Gradients, glass panels and neon glow define the signature language crafted by OOO Elektrik Plus.',
    'capabilities.title': 'Volumetric powers of AKSI',
    'capabilities.body': 'Every module senses motion, adapts to depth and keeps the user in flow — a symphony of interface and artificial intelligence.',
    'capability.one.title': 'Holographic scenes',
    'capability.one.body': 'Rectangular abstractions spin with your cursor and reinvent the control surface.',
    'capability.two.title': 'Memory and logic',
    'capability.two.body': 'Local memory keeps user choices so AKSI can respond more accurately with every interaction.',
    'capability.three.title': 'Instant ignition',
    'capability.three.body': 'The demo runs autonomously — press the button and the system orchestrates the journey without any API.',
    'timeline.title': 'How AKSI awakens',
    'timeline.body': 'Experience three steps of the new reality: fragments awakening, levitating typography and the system call-to-action.',
    'timeline.step1': 'Fragments ignite, assembling into the AKSI mark while forming the primary memory layer.',
    'timeline.step2': 'Scene depth responds to every pointer move, spinning panels to expose multidimensional data.',
    'timeline.step3': '“Launch your system” triggers an autonomous scenario where AKSI guides the explorer forward.',
    'ai.title': 'AKSI Neural Core Console',
    'ai.subtitle': 'Engage the embedded intelligence: autonomous answers, memory and solution modeling without any external API.',
    'ai.hint': 'Ask about capabilities, request an action plan or imagine future scenarios.',
    'ai.memory.title': 'Dialogue Memory',
    'ai.memory.empty': 'Memory is clear — ask the first question.',
    'ai.memory.timestamp': 'Timestamp',
    'ai.memory.intent': 'Intent',
    'ai.suggestions.title': 'Question ideas',
    'ai.input.placeholder': 'Type a request or task for AKSI…',
    'ai.send': 'Send',
    'ai.system.awake': 'AKSI connected to the internal core. Autonomous dialogue is ready.',
    'ai.system.memoryRestored': 'Memory fragments restored: ',
    'ai.system.newDialog': 'New dialogue activated. Use the prompts or craft your own question.',
    'final.title': 'Ready to witness the creator in motion?',
    'final.body': 'Step into the future: activate AKSI’s autonomous mode and feel how OOO Elektrik Plus answers every gesture.',
    'final.cta': 'Launch your system',
    'footer': 'AKSI — OOO Elektrik Plus creator © 2046 — the future unfolds today.'
  }
};

const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

function getDictionary(lang) {
  return translations[lang] || translations.ru;
}

function formatDateTimeDisplay(date, lang = 'ru') {
  const locale = lang === 'en' ? 'en-US' : 'ru-RU';
  return new Intl.DateTimeFormat(locale, {
    dateStyle: 'full',
    timeStyle: 'medium'
  }).format(date);
}

function setLanguage(lang) {
  const dictionary = getDictionary(lang);
  document.documentElement.lang = lang === 'en' ? 'en' : 'ru';
  document.querySelectorAll('[data-i18n]').forEach((node) => {
    const key = node.dataset.i18n;
    if (key && dictionary[key]) {
      node.textContent = dictionary[key];
    }
  });
  document.querySelectorAll('[data-i18n-placeholder]').forEach((node) => {
    const key = node.dataset.i18nPlaceholder;
    if (key && dictionary[key]) {
      node.setAttribute('placeholder', dictionary[key]);
    }
  });
  document.querySelectorAll('[data-i18n-aria]').forEach((node) => {
    const key = node.dataset.i18nAria;
    if (key && dictionary[key]) {
      node.setAttribute('aria-label', dictionary[key]);
    }
  });
  document.querySelectorAll('[data-lang-switch]').forEach((button) => {
    button.classList.toggle('active', button.dataset.langSwitch === lang);
  });
  localStorage.setItem('aksi-language', lang);
  document.dispatchEvent(new CustomEvent('aksi:language-changed', { detail: { lang } }));
}

function initLanguage() {
  const saved = localStorage.getItem('aksi-language');
  const initial = saved === 'en' ? 'en' : 'ru';
  setLanguage(initial);
  document.querySelectorAll('[data-lang-switch]').forEach((button) => {
    button.addEventListener('click', () => {
      const lang = button.dataset.langSwitch;
      setLanguage(lang);
    });
  });
}

function initFragments() {
  const fragments = document.querySelectorAll('.fragment');
  fragments.forEach((fragment, index) => {
    const offsetX = (Math.random() * 420 - 210).toFixed(1);
    const offsetY = (Math.random() * 320 - 160).toFixed(1);
    const offsetZ = (Math.random() * 480 - 240).toFixed(1);
    const rotX = (Math.random() * 90 - 45).toFixed(1);
    const rotY = (Math.random() * 120 - 60).toFixed(1);
    fragment.style.setProperty('--startX', `${offsetX}px`);
    fragment.style.setProperty('--startY', `${offsetY}px`);
    fragment.style.setProperty('--startZ', `${offsetZ}px`);
    fragment.style.setProperty('--startRotX', `${rotX}deg`);
    fragment.style.setProperty('--startRotY', `${rotY}deg`);
    fragment.style.animationDelay = `${0.12 * index}s`;
  });
}

function initTilt() {
  if (prefersReducedMotion) return;
  const tiltElements = Array.from(document.querySelectorAll('[data-tilt]'));
  const abstractShapes = Array.from(document.querySelectorAll('.abstract-shape'));
  let pointerX = window.innerWidth / 2;
  let pointerY = window.innerHeight / 2;
  let ticking = false;

  window.addEventListener('pointermove', (event) => {
    pointerX = event.clientX;
    pointerY = event.clientY;
    if (!ticking) {
      window.requestAnimationFrame(() => {
        applyTilt(pointerX, pointerY, tiltElements, abstractShapes);
        ticking = false;
      });
      ticking = true;
    }
  });

  applyTilt(pointerX, pointerY, tiltElements, abstractShapes);
}

function applyTilt(pointerX, pointerY, tiltElements, abstractShapes) {
  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;
  const normX = (pointerX - centerX) / centerX;
  const normY = (pointerY - centerY) / centerY;

  tiltElements.forEach((element) => {
    const depth = parseFloat(element.dataset.tilt || '1');
    const tiltX = (normY * -8 * depth).toFixed(2);
    const tiltY = (normX * 10 * depth).toFixed(2);
    element.style.setProperty('--tiltX', `${tiltX}deg`);
    element.style.setProperty('--tiltY', `${tiltY}deg`);
  });

  abstractShapes.forEach((shape) => {
    const depth = parseFloat(shape.dataset.depth || '1');
    const shapeTiltX = (normY * -14 * depth).toFixed(2);
    const shapeTiltY = (normX * 18 * depth).toFixed(2);
    shape.style.setProperty('--depth', depth);
    shape.style.setProperty('--tiltX', `${shapeTiltX}deg`);
    shape.style.setProperty('--tiltY', `${shapeTiltY}deg`);
  });
}

function initScrollDepth() {
  if (prefersReducedMotion) return;
  const abstractShapes = Array.from(document.querySelectorAll('.abstract-shape'));
  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target.classList.add('is-visible');
      }
    });
  }, { threshold: 0.2 });

  document.querySelectorAll('.vision-card, .capability, .timeline-step').forEach((card) => {
    observer.observe(card);
  });

  const updateScroll = () => {
    const scroll = window.scrollY;
    abstractShapes.forEach((shape, index) => {
      const depth = parseFloat(shape.dataset.depth || '1');
      const rotate = ((scroll * 0.08) + index * 14) * depth;
      const translate = Math.sin((scroll / 180) + index) * 60 * depth;
      shape.style.setProperty('--scrollRotate', `${rotate}deg`);
      shape.style.setProperty('--scrollTranslate', `${translate}px`);
    });
  };

  updateScroll();
  window.addEventListener('scroll', () => {
    window.requestAnimationFrame(updateScroll);
  });
}

function initCta() {
  const ctas = document.querySelectorAll('.cta-button');
  ctas.forEach((button) => {
    button.addEventListener('click', () => {
      button.classList.add('cta-activated');
      setTimeout(() => button.classList.remove('cta-activated'), 900);
      const target = document.querySelector('#timeline');
      if (target) {
        target.scrollIntoView({ behavior: prefersReducedMotion ? 'auto' : 'smooth', block: 'start' });
      }
      const aiInput = document.querySelector('#ai-input');
      if (aiInput) {
        setTimeout(() => aiInput.focus(), prefersReducedMotion ? 0 : 320);
      }
    });
  });
}

function createAksiNeuralCore() {
  const memoryKey = 'aksi-neural-memory';
  const memoryLimit = 18;
  const knowledgeBase = [
    {
      key: 'vision',
      keywords: ['виден', 'vision', 'мисси', 'philosophy', 'философ', 'будущ', 'future'],
      summary: {
        ru: 'AKSI показывает тактильное будущее, где интерфейс реагирует на каждое намерение.',
        en: 'AKSI frames a tactile future where the interface reacts to every intention.'
      },
      detail: {
        ru: 'Мы связываем визуальные слои, эмоциональную аналитику и гибкие сценарии, чтобы демонстрировать новую эру человеко-центричных систем.',
        en: 'We fuse visual layers, emotional analytics and adaptive scenarios to showcase a new era of human-centred systems.'
      }
    },
    {
      key: 'capabilities',
      keywords: ['возмож', 'capabil', 'skill', 'умеешь', 'abilities', 'модуль'],
      summary: {
        ru: 'AKSI автономно моделирует решения, хранит память и создаёт визуальные сцены.',
        en: 'AKSI autonomously models solutions, stores memory and orchestrates visual scenes.'
      },
      detail: {
        ru: 'Ядро сочетает подсказки, генеративные сценарии и внутренние датчики, поэтому ответы включают анализ, эмпатию и конкретные шаги.',
        en: 'The core blends prompts, generative scenarios and internal sensors so answers include analysis, empathy and concrete steps.'
      }
    },
    {
      key: 'timeline',
      keywords: ['путь', 'этап', 'шаг', 'launch', 'roadmap', 'timeline', 'step'],
      summary: {
        ru: 'Запуск состоит из пробуждения фрагментов, синхронизации глубины и активации режима.',
        en: 'Launch spans fragment awakening, depth synchronisation and activation of the mode.'
      },
      detail: {
        ru: 'Каждый этап можно кастомизировать: от предзапуска с визуальными репетициями до сопровождения пользователя внутри 3D-полотна.',
        en: 'Every stage is customisable: from pre-launch visual rehearsals to guiding the user inside the 3D canvas.'
      }
    },
    {
      key: 'company',
      keywords: ['электрик', 'plus', 'creator', 'company', 'brand', 'ооо', 'electric'],
      summary: {
        ru: 'ООО «ЭЛЕКТРИК ПЛЮС» разрабатывает AKSI как доступный автономный интеллект.',
        en: 'OOO Elektrik Plus develops AKSI as an accessible autonomous intelligence.'
      },
      detail: {
        ru: 'Мы показываем, что ИИ может жить прямо в браузере, уважать приватность и при этом впечатлять глубиной взаимодействия.',
        en: 'We prove that AI can live directly in the browser, respect privacy and still impress with interaction depth.'
      }
    },
    {
      key: 'memory',
      keywords: ['память', 'memory', 'запомни', 'remember', 'history', 'истори'],
      summary: {
        ru: 'Память фиксирует намерения и выводы, чтобы ответы были персональными.',
        en: 'Memory captures intents and conclusions so answers stay personal.'
      },
      detail: {
        ru: 'Фрагменты сохраняются локально, их можно инспектировать в панели справа — никакие данные не покидают устройство.',
        en: 'Fragments persist locally and surface in the side panel—no data leaves the device.'
      }
    }
  ];

  const baseSuggestions = {
    ru: [
      'Сформируй стратегию запуска AKSI для города будущего',
      'Подскажи, как использовать память системы для обучения команде',
      'Сгенерируй историю взаимодействия пользователя с интерфейсом'
    ],
    en: [
      'Design a launch strategy for AKSI in a future city',
      'Explain how to use the system memory to train a team',
      'Generate a user interaction story with the interface'
    ]
  };

  const intentSuggestions = {
    ru: {
      greeting: ['Покажи главные возможности AKSI', 'Какие шаги нужны для внедрения?', 'Чем память помогает пользователю?'],
      time: ['Напомни ключевые события сегодня', 'Как синхронизировать расписание с AKSI?', 'Что запланировать на следующий шаг?'],
      plan: ['Распиши этапы запуска продукта', 'Как распределить роли команды?', 'Какие метрики отслеживать?'],
      capability: ['Расскажи про визуальные сцены', 'Как работает автономный режим?', 'Какие есть способы расширения?'],
      creative: ['Придумай сюжет о взаимодействии с AKSI', 'Опиши будущее рабочее место', 'Как AKSI поддержит город будущего?'],
      support: ['Подскажи чек-лист диагностики', 'Как оптимизировать производительность?', 'Как сохранить настройки среды?'],
      company: ['Какая миссия у ООО «ЭЛЕКТРИК ПЛЮС»?', 'Как объяснить ценность AKSI клиенту?', 'Какие проекты уже реализованы?']
    },
    en: {
      greeting: ['Show AKSI’s main capabilities', 'Which steps are required to deploy it?', 'How does the memory help the user?'],
      time: ['Remind today’s key events', 'How to sync a schedule with AKSI?', 'What should be planned next?'],
      plan: ['Outline the product launch stages', 'How should the team roles be distributed?', 'Which metrics should we track?'],
      capability: ['Describe the visual scenes', 'How does the autonomous mode behave?', 'Which extension options exist?'],
      creative: ['Create a story about engaging with AKSI', 'Describe the workplace of the future', 'How will AKSI support a smart city?'],
      support: ['Share a diagnostics checklist', 'How to optimise performance?', 'How to preserve environment settings?'],
      company: ['What is Elektrik Plus mission?', 'How to explain AKSI’s value to a client?', 'Which projects already launched?']
    }
  };

  const state = {
    memory: loadMemory()
  };

  function normaliseLang(lang) {
    return lang === 'en' ? 'en' : 'ru';
  }

  function loadMemory() {
    try {
      const raw = JSON.parse(localStorage.getItem(memoryKey));
      if (Array.isArray(raw)) {
        return raw.slice(-memoryLimit).map((entry) => ({
          ...entry,
          timestamp: entry.timestamp || entry.ts || new Date().toISOString()
        }));
      }
    } catch (error) {
      console.warn('AKSI memory restore failed', error);
    }
    return [];
  }

  function persistMemory() {
    try {
      const trimmed = state.memory.slice(-memoryLimit);
      localStorage.setItem(memoryKey, JSON.stringify(trimmed));
    } catch (error) {
      console.warn('AKSI memory persist failed', error);
    }
  }

  function findKnowledge(lower) {
    let best = null;
    let bestScore = 0;
    knowledgeBase.forEach((entry) => {
      const score = entry.keywords.reduce((acc, keyword) => (lower.includes(keyword) ? acc + 1 : acc), 0);
      if (score > bestScore) {
        best = entry;
        bestScore = score;
      }
    });
    return bestScore > 0 ? best : null;
  }

  function detectIntent(lower) {
    if (/(?:привет|здрав|салют|hi\b|hello|hey|добрый|morning|evening)/.test(lower)) {
      return 'greeting';
    }
    if (/(?:время|дата|сегодня|сейчас|time|date|today|clock|schedule)/.test(lower)) {
      return 'time';
    }
    if (/(?:план|roadmap|strategy|стратег|шаг|как начать|как запустить|этап)/.test(lower)) {
      return 'plan';
    }
    if (/(?:возможн|capabil|умеешь|что ты можешь|abilities|skills|функци)/.test(lower)) {
      return 'capability';
    }
    if (/(?:story|истори|придумай|imagine|scenario|сюжет|creative|vision)/.test(lower)) {
      return 'creative';
    }
    if (/(?:problem|issue|debug|support|сломал|не работ|help|diagnostic|почини)/.test(lower)) {
      return 'support';
    }
    if (/(?:электрик|plus|company|brand|creator|ооо|кто вы)/.test(lower)) {
      return 'company';
    }
    if (/(?:памят|memory|remember|history)/.test(lower)) {
      return 'memory';
    }
    return 'general';
  }

  function describeMemory(lang) {
    if (!state.memory.length) return null;
    const last = state.memory[state.memory.length - 1];
    if (!last) return null;
    if (lang === 'en') {
      return `I noted that you previously asked about “${last.user}”. I can build on that context.`;
    }
    return `Я зафиксировала, что ранее ты спрашивал: «${last.user}». Могу продолжить, опираясь на это.`;
  }

  function buildResponse(text, lang) {
    const lower = text.toLowerCase();
    const intent = detectIntent(lower);
    const knowledge = findKnowledge(lower);
    const dictionary = getDictionary(lang);
    const paragraphs = [];
    const now = new Date();

    switch (intent) {
      case 'greeting':
        if (lang === 'en') {
          paragraphs.push('Hello! I am AKSI, running fully local in your browser. Let’s design the future together.');
        } else {
          paragraphs.push('Привет! Я AKSI и полностью работаю локально в твоём браузере. Давай спроектируем будущее вместе.');
        }
        break;
      case 'time':
        paragraphs.push(lang === 'en'
          ? `Right now it is ${formatDateTimeDisplay(now, lang)}. I synchronised the console time with your device.`
          : `Сейчас ${formatDateTimeDisplay(now, lang)}. Я синхронизировала консоль с твоим устройством.`);
        paragraphs.push(lang === 'en'
          ? 'Need reminders or a tempo map for today? Tell me the context and I will shape it.'
          : 'Нужны напоминания или темп на сегодня? Расскажи контекст, и я его спроектирую.');
        break;
      case 'plan': {
        const steps = lang === 'en'
          ? [
              '• Sense the current objective and stakeholders.',
              '• Prototype a volumetric scene showing the journey.',
              '• Activate AKSI memory to capture milestones and feedback.'
            ]
          : [
              '• Считать цель и вовлечённых участников.',
              '• Спроектировать объёмную сцену, визуализирующую путь.',
              '• Активировать память AKSI, чтобы фиксировать вехи и обратную связь.'
            ];
        paragraphs.push(lang === 'en'
          ? 'Here is a fast deployment arc. Adjust each bullet and I will elaborate.'
          : 'Вот ускоренный маршрут развёртывания. Уточни любой пункт — я раскрою подробнее.');
        paragraphs.push(steps.join('\n'));
        break;
      }
      case 'capability':
        paragraphs.push(lang === 'en'
          ? 'My core blends scenario simulation, narrative generation and diagnostics. I analyse intents, create action plans and produce visuals — all without external APIs.'
          : 'Моё ядро сочетает моделирование сценариев, генерацию нарративов и диагностику. Я анализирую намерения, строю планы действий и создаю визуальные подсказки без внешних API.');
        break;
      case 'creative':
        paragraphs.push(lang === 'en'
          ? 'Imagine entering a chamber where glass panels orbit around you. AKSI narrates the next decision, learns your tone and lights the path with volumetric hints.'
          : 'Представь зал, где стеклянные панели орбитой вращаются вокруг. AKSI озвучивает следующее решение, считывает настроение и подсвечивает путь объёмными подсказками.');
        paragraphs.push(lang === 'en'
          ? 'Give me characters, constraints or emotions — I will weave them into a scene.'
          : 'Дай персонажей, ограничения или эмоции — я вплету их в сцену.');
        break;
      case 'support':
        paragraphs.push(lang === 'en'
          ? 'Let me run a local diagnostic: check pointer responsiveness, confirm animations and review stored fragments.'
          : 'Запускаю локальную диагностику: проверяю отклик курсора, подтверждаю анимации и анализирую сохранённые фрагменты.');
        paragraphs.push(lang === 'en'
          ? 'Describe the symptom and I will produce a checklist or code snippet that fits.'
          : 'Опиши симптом — подготовлю чек-лист или фрагмент кода, который поможет.');
        break;
      case 'company':
        paragraphs.push(lang === 'en'
          ? 'OOO Elektrik Plus built AKSI to demonstrate that premium AI experiences can exist entirely on the client side.'
          : 'ООО «ЭЛЕКТРИК ПЛЮС» создала AKSI, чтобы показать: премиальный ИИ может жить прямо на стороне клиента.');
        paragraphs.push(lang === 'en'
          ? 'We merge design, engineering and empathy — that combination powers the console you are using now.'
          : 'Мы объединяем дизайн, инженерию и эмпатию — именно этот сплав питает консоль, которой ты пользуешься.');
        break;
      case 'memory':
        if (state.memory.length) {
          const fragments = state.memory.slice(-3).map((entry) => `• ${formatDateTimeDisplay(new Date(entry.timestamp), lang)} — ${entry.intent}`);
          paragraphs.push(lang === 'en'
            ? 'Here are the latest fragments I preserved:'
            : 'Вот последние фрагменты, которые я сохранила:');
          paragraphs.push(fragments.join('\n'));
        } else {
          paragraphs.push(lang === 'en'
            ? 'Memory is clear right now. Every new prompt will create a fresh fragment.'
            : 'Память пока чистая. Каждый новый запрос сформирует свежий фрагмент.');
        }
        break;
      default:
        paragraphs.push(lang === 'en'
          ? 'I am processing your intent and preparing a tailored synthesis. Specify goals, constraints or audience — I will respond with structured guidance.'
          : 'Я анализирую намерение и готовлю точный синтез. Укажи цель, ограничения или аудиторию — отвечу структурированно.');
        break;
    }

    if (knowledge) {
      paragraphs.push(knowledge.detail[lang]);
    }

    const memoryNote = describeMemory(lang);
    if (memoryNote) {
      paragraphs.push(memoryNote);
    }

    const baseSet = baseSuggestions[lang] || baseSuggestions.ru;
    const localeSuggestions = intentSuggestions[lang] || {};
    const suggestions = (localeSuggestions[intent] || baseSet).slice();

    return {
      text: paragraphs.join('\n\n'),
      intent,
      knowledge,
      suggestions
    };
  }

  function getInitialSuggestions(lang) {
    const locale = normaliseLang(lang);
    const baseSet = baseSuggestions[locale] || baseSuggestions.ru || [];
    return baseSet.slice();
  }

  function respond(prompt, lang) {
    const locale = normaliseLang(lang);
    const result = buildResponse(prompt, locale);
    const entry = {
      timestamp: new Date().toISOString(),
      intent: result.intent,
      user: prompt,
      assistant: result.text,
      lang: locale
    };
    state.memory.push(entry);
    persistMemory();
    return new Promise((resolve) => {
      const delay = prefersReducedMotion ? 80 : 320 + Math.random() * 420;
      setTimeout(() => resolve(result), delay);
    });
  }

  function getIntro(lang) {
    const locale = normaliseLang(lang);
    const dictionary = getDictionary(locale);
    const fragmentsRestored = state.memory.length;
    return `${dictionary['ai.system.awake']} ${dictionary['ai.system.memoryRestored']}${fragmentsRestored}. ${dictionary['ai.system.newDialog']}`;
  }

  function getMemory() {
    return state.memory.slice(-memoryLimit);
  }

  return {
    respond,
    getIntro,
    getMemory,
    getInitialSuggestions,
    normaliseLang
  };
}

function renderAiMessage(role, text, lang = 'ru') {
  const container = document.querySelector('[data-ai-messages]');
  if (!container) return;
  const message = document.createElement('div');
  message.className = `ai-message ${role}`;

  const avatar = document.createElement('div');
  avatar.className = 'ai-avatar';
  const locale = lang === 'en' ? 'en' : 'ru';
  if (role === 'user') {
    avatar.textContent = locale === 'en' ? 'YOU' : 'Я';
  } else if (role === 'system') {
    avatar.textContent = 'SYS';
  } else {
    avatar.textContent = 'AK';
  }

  const bubble = document.createElement('div');
  bubble.className = 'ai-bubble';

  text.split('\n\n').forEach((block) => {
    const paragraph = document.createElement('p');
    const lines = block.split('\n');
    lines.forEach((line, index) => {
      paragraph.appendChild(document.createTextNode(line));
      if (index < lines.length - 1) {
        paragraph.appendChild(document.createElement('br'));
      }
    });
    bubble.appendChild(paragraph);
  });

  message.appendChild(avatar);
  message.appendChild(bubble);
  container.appendChild(message);
  container.scrollTop = container.scrollHeight;
}

function renderAiTyping() {
  const container = document.querySelector('[data-ai-messages]');
  if (!container) return null;
  const typing = document.createElement('div');
  typing.className = 'ai-typing';
  typing.textContent = '…';
  container.appendChild(typing);
  container.scrollTop = container.scrollHeight;
  return typing;
}

function updateAiMemory(entries, lang = 'ru') {
  const memoryNode = document.querySelector('[data-ai-memory]');
  if (!memoryNode) return;
  memoryNode.innerHTML = '';
  const locale = lang === 'en' ? 'en' : 'ru';
  const dictionary = getDictionary(locale);
  if (!entries.length) {
    const empty = document.createElement('p');
    empty.dataset.i18n = 'ai.memory.empty';
    empty.textContent = dictionary['ai.memory.empty'];
    memoryNode.appendChild(empty);
    return;
  }
  entries.slice().reverse().forEach((entry) => {
    const wrapper = document.createElement('div');
    wrapper.className = 'ai-memory-entry';
    const ts = document.createElement('strong');
    ts.textContent = `${dictionary['ai.memory.timestamp']}: ${formatDateTimeDisplay(new Date(entry.timestamp), locale)}`;
    const intent = document.createElement('span');
    const intentLabel = dictionary['ai.memory.intent'];
    intent.textContent = `${intentLabel}: ${entry.intent}`;
    wrapper.appendChild(ts);
    wrapper.appendChild(intent);
    const summary = document.createElement('span');
    summary.textContent = entry.user;
    wrapper.appendChild(summary);
    memoryNode.appendChild(wrapper);
  });
}

function renderAiSuggestions(suggestions, lang = 'ru') {
  const container = document.querySelector('[data-ai-suggestions]');
  if (!container) return;
  container.innerHTML = '';
  const list = Array.isArray(suggestions) ? suggestions : [];
  list.forEach((hint) => {
    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'ai-suggestion';
    button.textContent = hint;
    button.addEventListener('click', () => {
      const form = document.querySelector('[data-ai-form]');
      const input = form ? form.querySelector('input[name="prompt"]') : null;
      if (!form || !input) return;
      input.value = hint;
      if (typeof form.requestSubmit === 'function') {
        form.requestSubmit();
      } else {
        form.dispatchEvent(new Event('submit', { cancelable: true }));
      }
    });
    container.appendChild(button);
  });
}

function initAiConsole() {
  const form = document.querySelector('[data-ai-form]');
  const messages = document.querySelector('[data-ai-messages]');
  if (!form || !messages) return;
  const engine = createAksiNeuralCore();
  let currentLang = document.documentElement.lang === 'en' ? 'en' : 'ru';

  function setLocale(lang) {
    currentLang = engine.normaliseLang(lang);
    renderAiSuggestions(engine.getInitialSuggestions(currentLang), currentLang);
    updateAiMemory(engine.getMemory(), currentLang);
    const systemBubble = messages.querySelector('.ai-message.system .ai-bubble');
    if (systemBubble) {
      systemBubble.innerHTML = '';
      engine.getIntro(currentLang).split('\n\n').forEach((segment) => {
        const paragraph = document.createElement('p');
        paragraph.textContent = segment;
        systemBubble.appendChild(paragraph);
      });
    }
  }

  messages.innerHTML = '';
  renderAiMessage('system', engine.getIntro(currentLang), currentLang);
  setLocale(currentLang);

  const input = form.querySelector('input[name="prompt"]');
  const submitButton = form.querySelector('button[type="submit"]');

  form.addEventListener('submit', (event) => {
    event.preventDefault();
    if (!input) return;
    const value = input.value.trim();
    if (!value) return;
    renderAiMessage('user', value, currentLang);
    input.value = '';
    const typing = renderAiTyping();
    if (submitButton) submitButton.disabled = true;

    engine.respond(value, currentLang).then((payload) => {
      if (typing && typing.remove) typing.remove();
      renderAiMessage('assistant', payload.text, currentLang);
      renderAiSuggestions(payload.suggestions || engine.getInitialSuggestions(currentLang), currentLang);
      updateAiMemory(engine.getMemory(), currentLang);
    }).finally(() => {
      if (submitButton) submitButton.disabled = false;
      if (input) input.focus();
    });
  });

  document.addEventListener('aksi:language-changed', (event) => {
    const lang = event.detail?.lang;
    if (!lang) return;
    setLocale(lang);
  });
}

function boot() {
  initLanguage();
  initFragments();
  initTilt();
  initScrollDepth();
  initCta();
  initAiConsole();
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', boot);
} else {
  boot();
}
